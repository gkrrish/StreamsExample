SpringBoot :
------------
spring-boot-starter (for standalone applications)
spring-boot-starter-web (for web & distributed applications)
spring-boot-starter-data-jpa (for Persistence layer)
spring-boot-stater-mail (For java mail api)
spring-boot-starter-test (For Unit Testing)

Advantages of Spring Boot
--------------------------
1) Starter poms
2) Auto Configuration
3) Embedded Servers
4) Actuators
5) Embedded Databases Integration
6) Rapid Application Development


Spring Boot main advantage is AutoConfiguration. Based on Starter poms spring boot will identify what configuration is required to run our application and it will provide that configuration.

	Ex: FrontController Configuration
            Web Application Deployment

-> Spring Boot provided actuators which are used to provide production ready features of our applications.

		1) What is health of application
		2) How many objects created in our app
		3) How much memory utilized
		4) How many classes loaded
		5) how many threads are running
		6) What are the config props loaded
		7) What are the last 100 requests came to our app

From Boot start class we have to understand below 2 things very clearly

	1) @SpringBootApplication
	2) SpringApplication.run( ) method

-> The @SpringBootApplication annotation is equal to below 3 annotations

	1) @SpringBootConfiguration
	2) @EnableAutoConfiguration
	3) @ComponentScan


-> SpringApplication.run() method is used to bootstrap our spring boot application.

Example :
---------
@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}


-> SpringApplication.run(..) method performs bootstrapping of spring boot application.

Note: Bootstrapping means starting the application.

-> By using spring Boot we can create 3 types of applications

		1) Reactive Application
		2) Web Application
		3) Standalone application

-> At the time of creating boot project, if we don't select any dependency it will add 'spring-boot-starter' dependency by default. This will be considered as Standalone application.
-> At the time of creating boot project, if we select 'spring-boot-starter-web' dependency then it will be considered as 'SERVLET' based application.
-> At the time of creating boot project, if we select 
'spring-boot-starter-webflux' dependency then it will be considered as 'REACTIVE' based application.

Note: In SpringApplication class constructor logic is available to identify what type of project we have created ( deduceFromClassPath() );


-> @SpringBootApplication annotation is equal to below 3 annotations

	1) @SpringBootConfiguration
	2) @EnableAutoConfiguration
	3) @ComponentScanning

SpringApplication.run() method will start boot application execution process.
-> Below things are executing as part of run( ) method.

	-> It will identify type of the project
			- Reactive (webflux starter)
			- Web Servlet (web starter)
			- Default Standalone (boot starter)

	-> It will start stop watch to calculate time
	-> It will start listeners based on spring.factories file
	-> It will prepare environment (profiles it will load)
	-> It will print banner (we can customize banner)
	-> It will create IOC based on application type
	-> It will prepare & refresh application context
	-> It will stop the StopWatch and will calculate total time
	-> Call Runners
	-> It returns IOC container reference( ConfigurableAppCtxt )


What is Component Scanning?
-----------------------------
-> Programmer has to enable component scanning in spring framework
-> Programmer no need to enable component scanning in spring boot (by default it is enabled as part of Start class)

-> Component Scanning is the process which is used to identify component classes (spring beans) available in the application.
-> Component Scanninng will work based on base package naming convention


*******************
Component scanning
*******************


-> Component Scanning is the process of identifying spring bean classes available in the application.
-> In Spring Boot, Component Scanning is enabled by default.
-> In Spring Boot, Component Scanning will start from base package.

Note: The package which contains start class is called as base package.

-> Once Base package scanning is completed, it will search for sub packages of base package and will scan them.

Note: The packages which are starting with base package name are called as Sub packages of base package.

		in.ashokit  -----------------> Base package
		in.ashokit.beans ------> It is sub package for base pkg
		in.ashokit.dao -------> It is sub package for base pkg
		in.ashokit.service ------> It is sub pkg for base pkg
		in.ashokit.controller-----> It is sub pkg for base pkg
		in.ashokit.util-------> It is sub pkg for base pkg
		in.ashokit.service.admin-----> It is sub pkg for base pkg
		com.ashokit.model ----------> Not a sub package

-> If we have multiple packages with different names then we have to specify @ComponentScan annotation like below


package in.ashokit;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackages = { "com.ashokit", "in.ashokit", "" })
public class Application {

	public static void main(String[] args) {
		ConfigurableApplicationContext ctxt = SpringApplication.run(Application.class, args);
	}
}

Note: It is highly recommended to follow base package naming convention so that we no need to write @ComponentScan manually.


Component Scanning is the process of identifying sping beans available in our application.
-> By default start class package will be considered as base package.
-> Component Scan will start from base package then it will scan sub packages of base package.

Note: The packages names which are starting with base package name are called as sub packages of base package.

-> If we have more than one base package then we should write @ComponentScan annotation at start class.
------------------------------------------------------------------------------*********************
What is Spring Bean?
*********************
---------------------------------------------------------------------------------
-> The java class which is managing by IOC is called as Spring Bean.
-> To represent java class as Spring Bean we have below annotations

@Component
@Service
@Repository

@Controller
@RestController

@Configuration
@Bean (This is method level annotation)



Stereotype annotations
------------------------------------------------------------------------
-> To represent java class as Spring Bean we will use Stereo Type annotations

@Component
@Service
@Repository

-> To represent java class as configuration class we will use @Configuration annotation.

Note: When we want to perform customized configuration then we will do that by using Configuration class with the help of @Configuration annotation.

-> If programmer wants to create object for the class and wants to represent that as Spring Bean then we will use @Bean annotation.

Note: @Bean annotation is method level annotation.
-------------------------------------------------------------------------

@Configuration
public class AppConfig{
    
     @Bean
     public DataSource getDataSource(){
		DataSource ds = new DataSource();
                   ds.setUname(uname);
		   ds.setPwd(Decryptor.decrypt(pwd));
			//set all values

		return ds;
     }
}
------------------------------------------------------------------------------
-> In application development we will use @Bean for below scenarios

			-> DataSource creation
			-> Swagger Docket obj creation
			-> Spring Security Configuration
			-> Kafka Producer Configuration
			-> Kafka Consumer Configuration etc...

------------------------------------------------------------------------------
-> Component Scan will start from base package. After base package scanning completed it will scan all sub packages in alphabetical order.

Note: @Bean annotated methods will be called at the end (after all packages are scanned).
-> @Bean annotated method can be available in any Spring Bean class but it is recommended to keep in Configuration class.



 @Configuration & @Bean annotations
--------------------------------------------------------------------
-> To represent java class as configuration class we will use @Configuration annotation.
-> If we want to customize the object creation for a class then we will write method and will use @Bean annotation.

	Ex: Security Configuration
	    Kafka Producer Configuration
	    Kafka Consumer Configuration
            RestTemplate Configuration
	    WebClient Configuration
            Swagger Configuration etc...

-> If we want IOC container to create object for class then we will use below annotations at class level

		@Component
		@Service
		@Repository

-> In Realtime we will develop our applications using Layered Architecture
		-> Presentation Layer (Ui)
		-> Web Layer (Controller Classes)
		-> Business Layer (Service classes)
		-> Persistence Layer (Dao/Repository classes)


-> User Interface Logic will be available in Presentation Layer
-> Web layer contains Controller classes which are responsible to handle request and response in web application.
-> Business Layer Contains Service classes which are responsible to execute business logic
  Ex: Sendng Email, Password Encryption & Decryption, Report Generation etc.

-> Persistence Layer Contains Dao/Repository classes which are responsible to communicate with database.
--------------------------------------------------------------------------------

-> Controller class method should call service class method so Service Class Object should be injected into controller class object.
-> Service class method should call dao method so dao class object should be injected into service class object.
-> To inject one class object into another class object we will use @Autowired annotation
-> The process of injecting one class object into another class object is called as  ' Dependency Injection '.
-> In Spring / Spring Boot IOC container is responsible to perform this Dependency Injection.

-> @Autowired annotation we can use at below 3 places

		1) At Constructor Level (Constructor Injection)
		2) At Setter Level (Setter Injection)
		3) At Field Level (Field Injection)
---------------------------------------------------------------------------------
package in.ashokit.dao;

import org.springframework.stereotype.Repository;

@Repository
public class UserDao {

	public boolean saveUser(String uname, String email, String pwd) {
		// logic to store in db
		System.out.println("Storing record in database....");
		return true;
	}
}

package in.ashokit.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import in.ashokit.dao.UserDao;

@Service
public class UserService {

	private UserDao userDao = null;

	@Autowired
	public UserService(UserDao userDao) {
		this.userDao = userDao;
	}

	public void registerUser() {
		boolean isSaved = userDao.saveUser("ashok", "ashokitschool@gmail.com", "ashok@123");
		if (isSaved) {
			System.out.println("Record Saved....");
		} else {
			System.out.println("Failed to save....");
		}
	}
}
-------------------------------------------------------------------------------
package in.ashokit;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

import in.ashokit.service.UserService;

@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		ConfigurableApplicationContext run = 
				SpringApplication.run(Application.class, args);

		UserService userService = run.getBean(UserService.class);

		userService.registerUser();
	}
}
------------------------------------------------------------------------------


 Autowiring
---------------------------------------------------------------
-> Autowiring is used to inject one class object into another class

-> Autowiring we can enable in 3 ways

		1) Constructor Level AW
		2) Setter Level AW
		3) Field Level AW


Constructor Injection
---------------------------------------------------------------------------------
-> The process of injecting dependent bean object into target bean object through target bean constructor is called as 'Constructor Injection'.
-> To peform Constructor Injection, IOC will create Dependent Bean object first then it will create Target Bean object.
-> To inform IOC to perform Constructor Injection we will write @Autowired annotation at target class constructor.

Note: If target class is having only one parameterized constructor then writing @Autowired is optional.


@Service
public class UserService {

	private UserDao userDao;

	@Autowired
	public UserService(UserDao userDao) {
		System.out.println("UserService :: 1-Param Constructor");
		this.userDao = userDao;
	}
}
---------------------------------------------------------------------------------
Today's session : Setter Injection
---------------------------------------------------------------------------------
-> The process of injecting dependent bean object into target bean object through target class setter method is called as Setter Injection.
-> To inform IOC to perform Setter Injection we will write @Autowired annotation at target class setter method.
-> In Setter Injection target bean object will be created first then dependent bean object will be created.


package in.ashokit.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import in.ashokit.dao.UserDao;
import in.ashokit.util.EmailUtils;
import in.ashokit.util.PwdUtils;

@Service
public class UserService {

	private PwdUtils pwdUtils;

	private EmailUtils emailUtils;

	private UserDao userDao;

	public UserService() {
		System.out.println("UserService::Constructor");
	}

	@Autowired
	public void setPwdUtils(PwdUtils pwdUtils) {
		this.pwdUtils = pwdUtils;
	}

	@Autowired
	public void setEmailUtils(EmailUtils emailUtils) {
		this.emailUtils = emailUtils;
	}

	@Autowired
	public void setUserDao(UserDao userDao) {
		this.userDao = userDao;
	}

	public void registerUser() {
		pwdUtils.encryptPwd();
		userDao.save();
		emailUtils.sendEmail();
		System.out.println("User Record Saved....");
	}

}
---------------------------------------------

 Setter Injection
-----------------------------------------------------------------------
-> The process of injecting dependent bean object into target bean object using target bean setter method is called as Setter Injection.
-> We can inject multiple dependent objects also using Setter methods.
Note: For every dependent object we have to write its own setter method.

-> After target bean created then setter method will be called to perform dependency injection.
-> To perform setter injection we will specify @Autowired at setter method level.
-------------------------------------------------------------------------
If we do both setter and constructor injection then what will happen?
-------------------------------------------------------------------------
-> Always constructor injection will happen first
-> After Constructor Injection, Setter Injection will execute
-> Finally, Setter Injection Value will override Constructor Injection Value. So Setter Injection is final.

----------------------------------------------------------------------
public class Demo{

    private Integer i ;

    public Demo(Integer i){
	this.i = i;
    }
    
    public void setI(Integer i){
	this.i = i;
    }
     public static void main(String... args){
	Demo d = new Demo(10); // Constructor Injection
	d.setI(20); //Setter Injection
	System.out.println(i); // output : 20
     }
}
------------------------------------------------------------------------
Field Injection In Spring

-> When we specify @Autowired annotation at variable evel then IOC will perform Field Injection.
-> To perform Field Injection IOC will internally uses Reflection API.
Note: Using Reflection API we can access private variables outside of the class also but it is not recommended approach.

-> With in one target class we can declare multiple dependent beans and we can injecting them using Field Injection.
Why Field Injection is not recommended ?
----------------------------------------------------------------------------------
1) Internally it will use Reflection Api to inject value into private variable outside of the class which is against OOPS principles.
-> With Field Injection if we inject too many dependencies our class will violates Single Responsibility Principle.



----------------------------------------------------------------------------
@Qualifier annotation
-----------------------------------------------------------------------
-> When we enable autowiring using @Autowired annotation by default it will use byType mechanism to identify dependent bean object.


@Service
public class ReportService {

	private IReport report;

	public ReportService(IReport report) {
		System.out.println("ReportService::Constructor");
		this.report = report;
	}
}

-> In the above example IReport is an interface. If there is only one implementation IOC will perform Dependency Injection.
-> If IReport is having more than one implementation then IOC will run into Ambiguity problem.
-> To resolve such kind of ambiguity problem we will use @Qualifier annotation.



package in.ashokit.service;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import in.ashokit.beans.IReport;

@Service
public class ReportService {

	private IReport report;

	public ReportService(@Qualifier("excel") IReport report) {
		System.out.println("ReportService::Constructor");
		this.report = report;
	}

	public void generateReport() {
		report.generate();
		System.out.println("Report Generation Completed....");
	}
}
---------------------------------------------------------------------------------------------
-> If more than one bean is eligible for Autowiring then we will use @Qualifier annotation to resolve that ambiguity problem.
-> @Autowired annotation we can use at 3 places hence @Qualifier annotation also can be used at those 3 places.

			1) Constructor level
			2) Setter level
			3) Field level
----------------------------------------------------------------------------------------------
Banner in Spring Boot
----------------------------------------------------------------------------------------------.
-> When Spring Boot application started it will print Spring logo on the console that is called as Spring Boot banner.
-> SpringApplication.run( ) method contains logic to print banner
->  Spring Boot banner works based on banner mode

		1) OFF
		2) LOG
		3) CONSOLE ( This is by default )

		spring.main.banner-mode=console

-> To customize banner text we can create banner.txt file in src/main/resources folder. Boot will load banner.txt file from src/main/resources folder by default.
-> In Realtime people will configure Project Name or Company Name as banner text in ASCII Format.
	URL to generate ASCII Text: https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type%20Something%20


-> Copy the ASCII Text and keep it in banner.txt file then boot will load it to print
----------------------------------------------------------------------------------------------
Runners in Spring Boot
----------------------------------------------------------------------------------------------
-> Runners are used to execute the logic only one time when the application got started.
-> Runners will be executed as part of SpringApplication.run ( ) method
-> In Spring Boot We can use 2 types of Runners

		1) ApplicationRunner

		2) CommandLineRunner

-> The above two are functional interfaces because they contain only one abstract method i.e run( ) method.
Usecases to go for Runners
-----------------------------
-> Load the data from database to cache.

-> Send email once application started


Runners in Spring Boot
-------------------------------------------------------------------------
-> Runners are used to execute logic only one time when the application got started.
-> Spring Boot supports for 2 types of Runners. They are

			1) ApplicationRunner
			2) CommandLineRunner

-> Runners will be called from SpringApplication.run( ) method.
-> We can use runner to load the data from database to cache once application started.
-> We can use runner to send the email to project management once application started.
----------------------------------------------------------------------------------

1) What is Spring Boot?
2) Spring vs SpringBoot
3) Spring Boot Advantages
	- Starter Pom
	- Auto Configuration
	- Embedded Servers
	- Embedded Databases
	- Actuators
	- Rapid Application Development
4) Spring Boot Dis-Advantage
5) Spring Initializr (start.spring.io)
6) Creating Spring Starter Project in STS
7) First Application Creation Using SpringBoot
8) Spring Boot Application Folder Structure
9) Spring Boot Start Class
10) SpringApplication.run ( ) method
11) @SpringBootApplication
		- @SpringBootConfiguration
		- @EnableAutoConfiguration
		- @ComponentScan
12) Component Scan
13) How to represent java class as Spring Bean?
14) Stereotype annotations
		- @Component
		- @Service
		- @Repository
15) @Configuration
16) @Bean
17) Base Package Convention
18) IOC Container
19) Dependency Injection
20) Constructor Injection
21) Setter Injection
22) Field Injection
23) Why Field Injection is not recommended
24) Autowiring
	- Constructor Level
	- Setter Level
	- Field Level
25) Autowiring Modes
26) @Qualifier & @Primary
27) Banner & Banner Modes
		- OFF
		- LOG
		- CONSOLE (By default)
28) Runners in Spring Boot
		- ApplicationRunner
		- CommandLineRunner

----------------------------------------------------------------------------
**************SPRING DATA JPA *******************************
-----------------------------------------------------------------------------


 Database Setup
-------------------------------------------------------------------------

-> To perform persistent operations we need persistent store.
-> Persistent Store is nothing but database where we can store the data permanently for future access.
-> We can perform below persistent operations in persitent store

		1) CREATE / INSERT
		2) UPDATE
		3) RETRIEVE
		4) UPDATE

-> In order to work with Databases we need to have below 2 softwares
			1) Database Server S/w
			2) Database Client S/w

-> For Oracle DB Server, SQL Developer software will be used as client
-> For MySQL DB server, Mysql workbench will be used as client

Database Setup (DB server & DB Client)
-------------------------------------------------------------------------
-> When we install oracle db in our system we will get sql commandline to execute sql queries.

Note: It is very difficult to write complex sql queries in command line.
In industry people will use SQL developer as a client software to write sql queries.
----------------------------------------------------------------------------------
-> To communicate with DB using data jpa our java application should have below things.

		1) DB Config

		2) Entity Class

		3) Repository Interface

-> DB Config contains Database Configuration Properites
	(Driver class, url, username and password)
-> The java class which is mapped with db table is called as Entity class.
-> Repository interface provided method to perform CRUD operations with db table.

----------------------------------------------------------------------------------
-> In spring boot application we will write db config in application.properties file

-------------------------------application.properties--------------------------
spring.datasource.url=
spring.datasource.username=
spring.datasource.password=
spring.datasource.driverClassName=
--------------------------------------------------------------------------------

-> Based on above properties Data JPA will create connection pool and it provide DB connection to communicate with database.

---------------------------------------Entity class-------------------------------

-> We will map our java class with database table using below annotations
 a) @Entity  : To represent java class as entity (It is mandatory)
 b) @Table  : To map class name with db table name (It is optional).

     Note: If db table name & entity class name is same then @Table is optional.

 c) @Id  : To represent primary key column mapped variable (It is mandatory)
 d) @Column : To map entity class variable with Db tbl column name (Optional)

    Note: If db table column name & entity cls varibale name is same then @Column is optional.

----------------------------------------------------------------------------------------------
-> Spring Data JPA provided 2 interfaces to perform curd operations. They are

	1) CrudRepository
	2) JpaRepository

-> CrudRepository provided methods to perform only CRUD operations 
-> JpaRepository provided methods to perform Crud operations + Pagination + Sorting

Note: JpaRepository is having more functionalities than CrudRepository
---------------------------------------------------------------------------------------------


Developing First Application Using Spring Data JPA
----------------------------------------------------------------------------------------------
1) Create a table in database

CREATE TABLE EMP_TBL(
    EMP_ID NUMBER(10),
    EMP_NAME VARCHAR2(20),
    EMP_SAL NUMBER(10,2),
    PRIMARY KEY (EMP_ID)
);

2) Create Spring Boot application with below dependencies

	1) spring-boot-starter-data-jpa
	2) oracle ( or ) mysql


3) Configure datasource properties in application.properties file

spring.datasource.url=jdbc:oracle:thin:@localhost:1521/XE
spring.datasource.username=IES_DEV
spring.datasource.password=IES_DEV
spring.datasource.driverClassName=jdbc.oracle.OracleDriver

4) Create Java class and map with db table
---------------------------------------------------------------------------------------------
@Entity
@Table(name="EMP_TBL")
public class Employee{

    @Id
    @Column(name="EMP_ID")
    private Integer empId;

    @Column(name="EMP_NAME")
    private String empName; 

    @Column(name="EMP_SAL")
    private Double empSal;

     //setters & getters
}
----------------------------------------------------------------------------------------------

5) Create a interface and extend the properties from Spring Data JPA Repository interface.

@Repository
public interface EmpRepository extends CrudRepository<Employee, Integer>{

}
----------------------------------------------------------------------------------------------

6) Get EmpRepository bean object in boot start class using IOC reference and call the methods to perform Crud operations.


------------------------------------------------------------------------------
Steps to develop first application using data jpa
------------------------------------------------------------------------
-> To develop our application using data jpa we have to select below starter
		'spring-boot-starter-data-jpa'
-> To communicate with database we need to have driver class. Every Database provided their own driver class

		Oracle -----> OracleDriver
		MySql ------> MySqlDriver
		SqlServer ----> SqlServerDriver

-> To Establish connection with DB we need to configure DB properties in application.properties file
-> To perform DB operations we need to create Entity and Repository


	Entity ---------> Mapping with db table
        Repository --------> Contains methods to perform operations

-------------------------------------------------------------------------

CrudRepository provided methods
------------------------------------------------------------------------
-> Spring Data Jpa provided repository interfaces to perform DB operations

	1) CrudRepository
	2) JpaRepository

-> CrudRepository provided methods to perform only crud operations
-> JpaRepository provided methods to perform crud operations + pagination + sorting also.
----------------------------------------------------------------------------------------------

-> If our interface extending the properties from JPA interfaces then we no need to write single line of code also to perform crud operations.

-> When we create our interface by extending jpa repository interface then implementation class will be created in the run time for our interface. By using that implementation class object we can call the methods to perform DB operations.

		Note: Implementation class is a proxy class.


CrudRepository interface methods
--------------------------------
save ( ) : To insert one record

saveAll ( ) : To insert collection of records

Note: We don't have update method.... save( ) method is polymorphic method. If primary key already exist then it will update the record else it will insert the record.

findById( ) : To retrieve record using Primary Key
findAllById ( ) : To retrieve records using multiple primary keys.
findAll ( ) : To retrieve all records available in table
existsById ( ) : To check presense of the record
count ( ): To check total no.of records in available in table.
deleteById ( ) : To delete a record using Primary Key
deleteAllById ( ) : To delete multiple records using primary keys
delete(E obj) : To delete record using entity obj
deleteAll ( ) : To delete all records from the table.
---------------------------------------------------------------------------------------------
-> In Data JPA we can perform DB operations in 3 ways

	1) Using predefined methods
	2) By Writing findBy methods
	3) By Using Custom Queries
------------------------------------------------------------------------------

CrudRepository interface methods
------------------------------------------------------------------------
-> CrudRepository is an interface available in data jpa

-> This interface provided several methods to perform Crud operations.

-------------------------------------------------------------------------

-> In Data JPA, we can perform DB operations in 3 ways

	1) Predefined methods
	2) findByXXX methods
	3) Custom Queries

-> Predefined methods we have executed in last session

findByXXX methods
------------------
-> findBy methods are used to perform retrival operatoins

-> When we write a findBy method Data JPA will construct the query based on our method name

-> Method Naming convention is very very important for findBy methods.

------------------------------------------------------------------------
package in.ashokit.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "EMP_TBL")
public class Employee {

	public Employee() {
	}

	public Employee(Integer empId, String empName, Double empSal) {
		this.empId = empId;
		this.empName = empName;
		this.empSal = empSal;
	}

	@Id
	@Column(name = "EMP_ID")
	private Integer empId;

	@Column(name = "EMP_NAME")
	private String empName;

	@Column(name = "EMP_SAL")
	private Double empSal;

	public Integer getEmpId() {
		return empId;
	}

}
-------------------------------------------------------------------------
package in.ashokit.repository;

import java.io.Serializable;
import java.util.List;

import org.springframework.data.repository.CrudRepository;

import in.ashokit.entity.Employee;

public interface EmpRepository extends CrudRepository<Employee, Serializable> {
	public List<Employee> findByEmpName(String name);
	public List<Employee> findByEmpSal(Double sal);
	public List<Employee> findByEmpNameAndEmpSal(String name, Double salary);
	public List<Employee> findByEmpSalGreaterThan(Double empSal);
	public List<Employee> findByEmpNameIn(List<String> names);

}
-----------------------------------------------------------------------------------
-> Using Data JPA we can execute custom queries also
-> To execute custom queries we will use @Query annotation.


What is the difference between HQL and Native SQL queries?
----------------------------------------------------------
-> In SQL queries we will use table name and column names directley
-> In HQL queries we will use Entity class name and variable names
-> SQL queries are database dependent
-> HQL queries are database in-dependent

Note: Database can't understand HQL... DB will understand only SQL. 
-> To convert HQL queries to SQL queries Dialect classes will be used.


SQL :: select emp_name from emp_tbl where emp_id=101;
HQL :: select empName from Employee where empId=101;

SQL :: select emp_name, emp_sal from emp_tbl where emp_id=101;
HQL :: select empName, empSal from Employee where empId=101;

SQL :: select * from emp_tbl where emp_id=101;
HQL :: from Employee where empId=101;


--------------------------------------------------------------------
CrudRepository methods, findBy methods, @Query
-------------------------------------------------------------------------
-> In Data jpa we can execute queries in 3 ways
		1) predefined methods
		2) findByXXX methods
		3) Custom Queries (@Query annotation)

-> We discussed about HQL & SQL queries
-> Dialect class is used to convert HQL query to SQL query.
------------------------------------------------------------------------
I have shared videos for below concepts
1) JpaRepository introduction
2) JpaRepository methods
3) Pagination
4) Sorting
5) Generators
6) Custom Generator
-------------------------------------------------------------------------
Query By Example
-------------------------------------------------------------------------

Requirement:
------------
Retrieve all Managers working for IRCTC project in Hyd location.
//if we select all 3 drop-down values then below query should execute

select * from emp_tbl where emp_role='Manager' and emp_project='IRCTC' and emp_location='HYD';

//if we select only emp_role then below query should execute
select * from emp_tbl where emp_role='Manager';

//if we select only emp_project then below query should execute
select * from emp_tbl where emp_project='SBI';

//if we select only emp_location then below query should execute
select * from emp_tbl where emp_location='PUNE';


public List<Employee> searchEmps(EmpSearchCriteria esc){
	StringBuilder sql = "select * from emp_tbl where 1=1";

  	if(esc.getEmpRole()!=null){
		sql.append(" and emp_role='+esc.getEmpRole()+"'";
 	}
        if(esc.getEmpProject()!=null){
               sql.append(" and emp_project='+esc.getEmpProject()+"'";
        }
	if(esc.getEmpLoc()!=null){
		sql.append(" and emp_loc='+esc.getEmpLoc()+"'";
        }
}
---------------------------------------------------------------------------------



Employee [empId=103, empName=John, empSal=18000.0]
Employee [empId=104, empName=Ram, empSal=23000.0]
Employee [empId=105, empName=Rani, empSal=24000.0]
Employee [empId=101, empName=Ashok, empSal=14000.0]
Employee [empId=102, empName=Kumar, empSal=15000.0]
Employee [empId=106, empName=Smith, empSal=15000.0]


Dynamic Query Creation Using Example
------------------------------------------------------------------------
Today's session : Connection Pooling
------------------------------------------------------------------------

-> If we want to communicate with database then we need to have connection with database.
-> If application having connection with database then only application can perform DB operations.
-> To establish connection with Database Java applications will use JDBC api.
-> In JDBC api we have DriverManager class to get connection with database.
	Connection con  = DriverManager.getConnection(url,uname,pwd);
-> getConnection(...) method returning Connection object.

Note: The connection which is returned by getConnection(...) method is physical connection. Its mandatory that we have to close that connection once our operation got completed.

-> When we open physical connections from database, if we forgot close them after sometime there is a change of getting connections exhausted problem.
-> To avoid this connection exhausted problem we will use Connection Pooling concept.

Connection Pooling
------------------
-> It is the process of getting connections when the application started and keeping them ready to use in the application.
-> Connection pooling will be managed by Pool Manager.
-> The connection which is taken from Connection Pool is called as Logical Connection.
-> If we forgot to close the logical connection then Pool Manager will close that connection.

Advantages of Connection Pooling
--------------------------------
-> No need to make network call everytime to get the connection with DB
-> Connection Exhausted problem can be avoided.
-> Spring Boot internally uses Hikari Connection Pool.

Note: We can customize connection pool properties using application.properties file.

	1) max-pool-size
	2) connection-timeout
	3) idel-timeout etc.

Transactions
--------------
-> For non-select operations (insert/delete/update) Transaction is mandatory
-> Data JPA is taking care of transactions which are required for Non-select operations.






Connection Pooling
------------------------------------------------------------------------
-> Connection pooling is used to avoid connections exhausted problem in our application.
-> Using Connection Pooling we can improve performance of our application (for every operation we no need to open connection with DB).
-------------------------------------------------------------------------
Working with Transactions in Data JPA
-------------------------------------------------------------------------
-> An unit amount of work is called as Transaction.
-> When we are performing operations with DB then Transactions are very very important.
-> Transaction is mandatory for non-select operations (Insert/Update/Delete)
-> Transaction is optional for select  operations (Retriving)
-----------------------------------------------------------------------------------
	Connection con = DriverManager.getConnection(Url, Uname, Pwd);
	Statement stmt = con.createStatement();
	int rowsEffected = stmt.executeUpdate(sqlQuery);

-> In JDBC connection obj will be created with default autoCommit mode. When we execute any non-select query using jdbc api then immediatley it will commit the transaction.
----------------------------------------------------------------------------------

-> In order to disable auto-commit mode in JDBC api we will use setAutoCommit(false).
		con.setAutoCommit(false);
		con.commit( ) or con.rollback( );
-> When we disable auto-commit mode then programmatically we have to commit the transaction or rollback the transaction manually.
	-> If all operations are successful in Tx then we will commit it
	-> If any one operation got failed in Tx then we will rollback it.
Transactions in application
-----------------------------------------------------------------------
-> When our application is performing DB operations then transactions are required.
-> Transaction is mandatory for only non-select operations
		Ex: create, update and delete
-> Transaction is optional for select operations.
How to rollback transaction in Data JPA
-------------------------------------------------------------------------
-> We can use @Transactional(rollbackFor=T) to rollback the transaction when exception occured.
-> If exception not occured then data jpa will commit the transaction
-------------------------------------------------------------------------
auto-ddl and composite primary key
------------------------------------------------------------------------
-> Hibernate provided several ORM properties for us to configure in the application
	show_sql : To print queries on the console
	format_sql : To print queries in formatted way
	dialect : To convert HQL queries to SQL queries
	auto-ddl : To generate schema dynamically
-> For auto-ddl property having 5 options
		1) create
		2) create-drop
		3) update
		4) validate
		5) none

-> 'create' option will always create the new tables. If tables are already existing it will drop the existing tables and will create new tables. We will loose table old data in this approach.
-> 'create-drop' option will create tables then it will perform the operation and it will delete the tables at the end. This option is used for staging operations.
-> 'update' option will create tables only for first time. If tables are already available then it will use existing tables.
-> 'validate' option will not make any changes to database. It will just verify entities with db tables.
-> 'none' option will disable auto-ddl in application. This is default value.
-----------------------------------------------------------------------------------
Primary and Composite Primary Key In Database
-----------------------------------------------------------------------------------

-> Primary Key is a constraint which is used to maintain unique data in the column.
-> Primary key constraint is the combination of below 2 constraints
			-> NOT NULL
			-> UNIQUE
-> To map variable with Primary Key Column we will use @Id annotation.
-> If a table is having more than one primary key then it is called as composite Primary Key.
------------------------------------------------------------------------
ddl-auto & composite primary key introduction
-------------------------------------------------------------------------
-> ddl-auto is an ORM property which is used to generate the schema dynamically based on entities.
-> ddl-auto property having 4 options
		1) create (always new table will be created)
		2) create-drop (create and drop the table)
		3) update (Only first time it will create tbl)
		4) validate (to verify schema details)
-> Primary key is a constraint which represents not null and unique value.
-> If table having more than one primary key then it is called as Composite Primary Key or Candidate key.
---------------------Tbl creation with PK-----------------------------------------
CREATE TABLE EMP_TBL(
  EMP_ID NUMBER(10),
  EMP_NAME VARCHAR2(20),
  EMP_SALARY NUMBER(10,2),
  PRIMARY KEY(EMP_ID)
)
---------------------TBL creation with Composite PK-------------------------------
CREATE TABLE ACCOUNTS(
  ACC_ID NUMBER(10),
  ACC_TYPE VARCHAR2(10),
  HOLDER_NAME VARCHAR2(20),
  MIN_BAL NUMBER(10,2),
  BRANCH_NAME VARCHAR2(20),
  PRIMARY KEY(ACC_ID, ACC_TYPE, HOLDER_NAME)
)
---------------------------------------------------------------------------------
-> We can map composite primary keys in 2 ways
		1) Using @IdClass annotation (approach-1)
		2) Using @Embeddable & @EmbeddedId annotations (approch-2)
-> Approach-1 & Approach-2 examples are given below
---------------------------------------------------------------------------------
Composite Primary Key - Approach - 1
----------------------------------------------------------------------------------
public class AccountPK implements Serializable {

	private Integer accId;
	private String accType;
	private String holderName;
	//setters & getters
}
-----------------------------------------------------------------------------------
@Entity
@Table(name = "BANK_ACCOUNTS")
@IdClass(AccountPK.class)
public class Account {

	@Column(name = "BRANCH_NAME")
	private String branchName;

	@Column(name = "MIN_BAL")
	private Double minBal;

	@Id
	private Integer accId;

	@Id
	private String accType;

	@Id
	private String holderName;

	//setters & getters
----------------------------------------------------------------------------------
package in.ashokit.service;

import org.springframework.stereotype.Service;

import in.ashokit.entity.Account;
import in.ashokit.entity.AccountPK;
import in.ashokit.repository.AccountRepository;

@Service
public class AccountService {

	private AccountRepository accRepo;

	public AccountService(AccountRepository accRepo) {
		this.accRepo = accRepo;
	}

	public void saveAccData() {
		Account acc = new Account();
		acc.setBranchName("Ameerpet");
		acc.setMinBal(5000.00);
		acc.setAccId(102);
		acc.setAccType("SAVINGS");
		acc.setHolderName("IBM");

		accRepo.save(acc);
	}
}
-----------------------------------------------------------------------------------
package in.ashokit;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

import in.ashokit.service.AccountService;

@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);

		AccountService accountService = context.getBean(AccountService.class);
		accountService.saveAccData();

		context.close();
	}
}
-----------------------------------------------------------------------------------
spring.datasource.url=jdbc:oracle:thin:@localhost:1521/XE
spring.datasource.username=IES_DEV
spring.datasource.password=IES_DEV
spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver

spring.jpa.show-sql=true

spring.jpa.hibernate.ddl-auto=update
-----------------------------------------------------------------------------------
Composite-Primary key : Approach-2
--------------------------------------------------------------------------------
package in.ashokit.entity;

import java.io.Serializable;

import javax.persistence.Embeddable;

@Embeddable
public class AccountPK implements Serializable {

	private Integer accId;
	private String accType;
	private String holderName;

	//setters & getters
}
----------------------------------------------------------------------------------
package in.ashokit.entity;

import javax.persistence.Column;
import javax.persistence.EmbeddedId;
import javax.persistence.Entity;
import javax.persistence.Table;

@Entity
@Table(name = "BANK_ACCOUNTS")
public class Account {

	@Column(name = "BRANCH_NAME")
	private String branchName;

	@Column(name = "MIN_BAL")
	private Double minBal;

	@EmbeddedId
	private AccountPK accPk;

	//setters & getters
}
----------------------------------------------------------------------------------
package in.ashokit.service;

import org.springframework.stereotype.Service;

import in.ashokit.entity.Account;
import in.ashokit.entity.AccountPK;
import in.ashokit.repository.AccountRepository;

@Service
public class AccountService {

	private AccountRepository accRepo;

	public AccountService(AccountRepository accRepo) {
		this.accRepo = accRepo;
	}

	public void saveAccData() {

		AccountPK pk = new AccountPK();
		pk.setAccId(103);
		pk.setAccType("SAVINGS");
		pk.setHolderName("TCS");

		Account acc = new Account();
		acc.setBranchName("Ameerpet");
		acc.setMinBal(5000.00);

		acc.setAccPk(pk); // setting pk class obj to entity obj

		accRepo.save(acc);
	}
}
---------------------------------------------------------------------------------
package in.ashokit;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

import in.ashokit.service.AccountService;

@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);

		AccountService accountService = context.getBean(AccountService.class);
		accountService.saveAccData();

		context.close();
	}
}
----------------------------------------------------------------------------------
How to retrieve data using Composite Primary Keys
----------------------------------------------------------------------------------
public void getDataUsingPK() {

		AccountPK pk = new AccountPK();
		pk.setAccId(101);
		pk.setAccType("CURRENT");
		pk.setHolderName("IBM");

		Optional<Account> findById = accRepo.findById(pk);
		if (findById.isPresent()) {
			System.out.println(findById.get());
		}
	}
-----------------------------------------------------------------------------------
-> All the primary key values we need to store in Embeddable class obj and pass that obj as parameter for findById( ) method like above.
-----------------------------------------------------------------------------------
Composite Primary Key example
-------------------------------------------------------------------------
Today's session : Timestamping In hibernate
------------------------------------------------------------------------
-> It is highly recommended to maintain created_date and updated_date values in table.
-> created_date and updated_Date column values will help us in anaylyzing the table data.
-> In realtime for every table we will have CREATED_DT and UPDATED_DT columns.
-> If we use timestamping concept then hibernate will take care of populating values into CREATED_DT and UPDATED_DT columns.
-> To work with Timestamping we have below 2 annotations
		1) @CreationTimestamp
		2) @UpdateTimestamp

-------------------------------------------------------------------------
@Entity
@Table(name = "INSURANCE_PLANS")
public class InsurancePlan {

	@Id
	@GeneratedValue
	private Integer planId;
	private String planName;
	private String planStatus;

	@CreationTimestamp
	@Column(updatable = false)
	private LocalDate createdDate;

	@UpdateTimestamp
	@Column(insertable = false)
	private LocalDate updatedDate;
------------------------------------------------------------------------
-> If we are using java.util.Date for variable data types then we can use @Temporal annotation to specify format of date.
-------------------------------------------------------------------------
1) Best Practises To Follow in Persistence Layer
2) Hibernate vs Data JPA
3) What is Entity class ?
4) What is Repository interface?
5) Data Jpa Repositories
		a) CrudRepository
		b) JpaRepository
6) Pagination
7) Sorting
8) QueryByExample
9) CrudRepository predefined methods
10) findByxxx methods syntax
11) Custom Queries in data jpa
12) Connection pooling (Hikari)
13) Transactions & How to rollback transactions
14) Primary Key & Composite Primary keys
15) Generators
16) Custom Generators

Timestamping in Hibernate
-------------------------------------------------------------------------
-> Timestamping is used to deal with creation_date and update_date columns in database.
		1)@CreationTimestamp
		2)@UpdateTimestamp
-------------------------------------------------------------------------
Today's session : Spring Web MVC Module (Part-3)
-----------------------------------------------------------------------------------
-> Spring Web MVC is one module available in Spring Framework
-> By Using Spring Web MVC module we can develop below types of applications
		1) Web Applications ( C 2 B )
		2) Distributed Applications (B 2 B)
-> Spring Boot also uses Spring Web MVC module internally to develop web applications.
-> Spring Web MVC module is developed based on 2 design patterns
		1) MVC Design Pattern
		2) Front Controll Design Pattern
MVC Design Pattern
-------------------
-> MVC stands for Model, View and Controller
-> Model represents data
-> View represents presentation logic
-> Controller is responsible for handling request (Mediator btwn Model and View)
-> MVC design pattern is used to develop our applications with loosely coupling.

FrontController Design Pattern
------------------------------
-> Spring MVC module is using front controller design pattern to deal with pre-processing and post-processing of a request.
-> In Spring MVC 'DispatcherServlet' acting as Front Controller.

Note: DispatcherServlet is a predefined class available in Spring MVC module.


---------------------------------------------------------------------------------**************Spring Web MVC Introduction**********
------------------------------------------------------------------------

Spring Web MVC Architecture
-------------------------------------------------------------------------

1) FrontController
2) HandlerMapper
3) Controller
4) ModelAndView
5) ViewResolver
6) View

What is FrontController?
----------------------------
-> FrontController is responsible to perform pre-processing and post-processing of a request.
-> In Spring Web MVC, DispatcherServlet will act as Front Controller
-> DispatcherServlet is a pre-defined class.

What is HandlerMapper?
----------------------
-> HandlerMapper is a pre-defined component available in Spring Web MVC
-> HandlerMapper is responsible to identify Request Handler class for incoming request.
-> From Spring 3.0 onwards RequestMappingHandlerMapper is executing as Default HandlerMapper.
What is Controller?
---------------------
-> Controller is web component which is responsible to handle web request
-> Controller is also called as Request Handler
-> To represent java class as a Controller we will use @Controller annotation.

What is ModelAndView?
---------------------
-> After handling the request, controller method will return ModelAndView object.
-> Model is a map which stores the data in the form of Key-Value pair
-> Model is used to send the data to presentation layer in key-value format.
-> View Represents Logical view name that should be rendered as a response.
Note: In Spring Web MVC, Controller don't know where the view files will be available and what is the view technology.

What is View Resolver?
----------------------
-> View Resolver is used to identify location of view files and view technology
-> We will configure ViewResolver with prefix and suffix

	prefix ------> Represents view files location
	suffix ------> Represents view files extension

What is View?
-------------
-> View Component is used to render model data in view file

Spring MVC Architecture
------------------------------------------------------------------------
1) Front Controller
2) Handler Mapper
3) Controller
4) ModelAndView
5) ViewResolver
6) View
-------------------------------------------------------------------------Today's session : First App Development using Spring Web MVC
-------------------------------------------------------------------------
1) Create Spring Starter Project with below dependencies

	a) spring-boot-starter-web
	b) spring-boot-devtools
	c) tomcat-embed-jasper

-> web-starter is used to develop web applications using Spring MVC. It will provide Tomcat as default embedded container.
-> devtools dependency is used to re-start the server when changes happend in project code/configuration.
-> tomcat-embed-jasper dependency is used to compile jsp files
Note: If tomcat-embed jasper dependency not available then jsp file will be downloaded when user make a request.
2) Configure below properties in application.properties file
	a) Embedded server port
	b) View Resolver
3) Create Controller class using @Controller annotation
4) Write method in controller class to handle the request
5) Create View file with presentation logic
6) Run the application and test it.


Methods in Controller class & Multiple Controllers
------------------------------------------------------------------------
-> To develop web application using Spring Boot we have to add below starter in pom.xml file
		spring-boot-starter-web
-> When we add spring-boot-starter-web dependency it will get 'Tomact' as default container.
-> Default Container runs on port number 8080. If we want to change that port number we have to write below property in application.properties file
		server.port = 9090
-> To represent class as a controller, we will use @Controller annotation.
-> Inside controller class we will write multiple methods and we will bind those methods to Http Protocol methods using below annotations

	GET Request ->	@GetMapping
	POST Request -> @PostMapping
	PUT Request -> @PutMapping
	DELETE Request -> @DeleteMapping

Note: Earlier people used to work with @RequestMapping annotation to bind controller methods to Http Protocol methods.
		@RequestMapping(value="", method=POST)

Spring MVC Controllers and Method
------------------------------------------------------------------------
-> In one application we can have multiple controllers.
-> One controller can have multiple methods
-> We need to make sure all the methods are binded to unique url patterns.
-> To avoid ambiguity problem in url patterns we will write both class level and method level url patterns.
-------------------------------------------------------------------------
Today's topic : Sending data from Controller to UI (response data)
-------------------------------------------------------------------------
-> In Spring MVC application, Controller is responsible for sending data to UI.
-> To send the data from Controller to UI we have Model or ModelAndView objects.
-> Model and ModelAndView objects will represent the data in key-value format.
	syntax: model.addAttribute(String key, Object value);
-> Based on keys we will access values in Presentation files using expression language.
		syntax :  ${key}

-------------------------------------------------------------------------
package in.ashokit.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class BookController {

	@GetMapping("/bookdata")
	public String getBookData(Model model) {

		// setting data to model obj
		model.addAttribute("name", "Spring Boot");
		model.addAttribute("author", "Rod Johnson");
		model.addAttribute("price", 450.00);

		return "book-data";// returning logical view name
	}
}

-----------------------------------------------------------------------
package in.ashokit.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.servlet.ModelAndView;

import in.ashokit.pojo.Product;

@Controller
public class ProductController {

	@GetMapping("/productdata")
	public ModelAndView getProductData() {
		ModelAndView mav = new ModelAndView();

		Product pobj = new Product();
		pobj.setProductId(101);
		pobj.setProductName("Keyboard");
		pobj.setProductPrice(1500.00);

		mav.addObject("product", pobj); // adding product obj to model in Key-value format
		
		mav.setViewName("product-data"); // setting logical view name

		return mav;
	}

}

-------------------------------------------------------------------------
package in.ashokit.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import in.ashokit.pojo.Plan;

@Controller
public class InsurancePlanController {

	@GetMapping("/plandata")
	@ResponseBody
	public Plan getPlanData() {

		Plan p = new Plan();
		p.setPlanId(101);
		p.setPlanName("Jeevan Anand");
		p.setPlanStatus("Approved");

		return p;
	}
}
-------------------------------------------------------------------------
package in.ashokit.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class IndexController {

	@GetMapping
	public String index() {
		return "index";
	}
}
------------------------------------------------------------------------
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
	pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>

	<h2>Welcome to our store.......</h2>
	<hr />
	<a href="bookdata">Get Book Data</a>
	<br />

	<a href="productdata">Get Product Data</a>
</body>
</html>
-------------------------------------------------------------------------
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
		<h2>Book Data</h2>
		
		Book Name : ${name} <br/>
		Author Name : ${author} <br/>
		Book Price: ${price} <br/>
		
		<a href="/">Home</a>
</body>
</html>
-------------------------------------------------------------------------
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
		<h2> Product Data </h2>
		Product ID : ${product.productId} <br/>
		
		Product Name : ${product.productName} <br/>
		
		Product Price : ${product.productPrice} <br/>
		
		<a href="/">Home</a>
</body>
</html>
-------------------------------------------------------------------------
Get Book Data Hyperlink =====>   localhost:9090/bookdata
Get Product Data Hyperlink ====> localhost:9090/productdata
Home Hyperlink ====> localhost:9090/
------------------------------------------------------------------------
 How to send data from UI to Controller
------------------------------------------------------------------------
-> In Web application we will have several scenarios to send data from UI to controller.

Examples:
----------
1) Getting Emp Salary Based on Emp ID
2) Getting Book Price based on ISBN
3) Getting Ticket Status based on Ticket ID
4) Storing Employee Information using Form
5) Searching Products in E-commerce application etc..
-------------------------------------------------------------------------
-> We can use below approches to send data from UI to Controller
	1) Query Parameter
	2) Path Parameter
	3) Request Body 
-------------------------------------------------------------------------
Query Parameters
-------------------------------------------------------------------------
-> Query Parameters are used to send data to server in URL
-> Query Parameter will represent data in key-value format
-> Query Parameter will start with '?' symbol
-> Query Parameter will be seperated by '&'
-> Query Parameter should present only at the end of the URL
  Ex-1:  www.ashokit.in?course=SBMS
  Ex-2:  www.ashokit.in?course=SBMS&trainer=Ashok
  Ex:3 : https://www.youtube.com/results?search_query=debugging+ashok+it
  Ex:4 : https://www.youtube.com/watch?v=2WxsClYhreE

-> To read query parameter from URL we will use @RequestParam annotation in controller.
	syntax : 
	@GetMapping("/getPrice")
	public ModelAndView getBookPrice(@RequestParam String isbn){
		//logic
		return mav;
	}

-------------------------------------------------------------------------
package in.ashokit.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@RequestMapping("/book")
public class BookController {

	@GetMapping("/price")
	@ResponseBody
	public String getBookPrice(@RequestParam("isbn") String str) {

		String msg = "The Book Price Of " + str + " Is  : 450.00 INR";

		return msg;
	}
	
}

-------------------------------------------------------------------------
package in.ashokit.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@RequestMapping("/book")
public class BookController {

	@GetMapping("/price")
	@ResponseBody
	public String getBookPrice(@RequestParam("isbn") String str) {

		String msg = "The Book Price Of " + str + " Is  : 450.00 INR";

		return msg;
	}
	
}

-------------------------------------------------------------------------
package in.ashokit.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class CourseController {

	@GetMapping("/course")
	@ResponseBody
	public String getCourseDtls(String cname, String trainer) {

		if (cname.equals("SBMS")) {
			String msg = cname + " By " + trainer + " Starting From 23-Jun-21 @6:30 AM IST";
			return msg;
		} else if (cname.equals("JRTP")) {
			String msg = cname + " By " + trainer + " Starting From 30-Jun-21 @11:30 AM IST";
			return msg;
		}
		return "Contact Admin Team :: + 91-6301921083";
	}
}
-------------------------------------------------------------------------
Note: If query-param key name is same as method parameter name then @RequestParam annotation is optional.

Query Parameters
-------------------------------------------------------------------------
-> Query Parameters are used to send data to server in URL
-> Query Parameters will be represented in Key-value format
-> Query Parameters will start with '?'
-> Query Parameters will be seperated by &
-> Query Parameters should present only at the end of the URL
-> To read Query Parameters we will use @RequestParam("key") annotation

	Ex: www.ashokit.in?course=SBMS

-------------------------------------------------------------------------
Today's session : Path Parameters
-------------------------------------------------------------------------
-> Path Parameters are used to send data to Server in URL
-> Path Parameters will represent data directley (No Key)
-> Path Parameters can present anywhere in the URL
-> Path Parameters will be seperated by slash ('/')
Note: Path Paramters should be represented in URL Pattern

	Sample URL : "/book/{isbn}/price"

Note: In the above URL 'isbn' is path parameter
-> To read path parameter values from URL we will use @PathVariable annotation in Controller class.

-------------------------------------------------------------------------
package in.ashokit;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class CarController {

	@GetMapping("/price/{carName}")
	@ResponseBody
	public String getCarPrice(@PathVariable("carName") String carName) {

		String msg = carName + " Price is 7.8 lakhs";

		return msg;
	}

	@GetMapping("/check/{carName}/{location}/{branch}/cars")
	@ResponseBody
	public String checkDtls(@PathVariable String carName, 
			@PathVariable String location, @PathVariable String branch) {

		String responseMsg = "In " + location + " " + branch + " Branch " + carName + " Cars are available";

		return responseMsg;
	}
}
----------------------------------------------------------------------------------

-> If we use Query Params or Path Params to send the data to server then data will be exposed in URL
-> If data is exposed in URL we have security breaches
Note-1: It is not at all recommended to send confidential information to server in the URL (password, credit card number, Pin number, SSN, Aadhar etcc)
Note-2: URL will have length limitation (we can send 1024 characters)
Note-3: We can't send binary data (videos, audios, images etc) in URL
------------------------------------------------------------------------------
-> If we want to send any small text information which is not sensitive then we can use Query Parameter and Path Parameter to send that data to server
-> In Web based application we will use Query Params
-> In Rest Apis we will use Path Params
-----------------------------------------------------------------------------------
-> To resolve drawbacks of Query Params and Path Params we will use Request Body to send huge/sensitive/confidential/binary data to server.
-> The data which is sending to server in Request Body will not be exposed in URL.

Form Development using MVC Tag Library
---------------------------------------------------------------------------------------------

1) Create Spring Boot Starter Project with below dependencies
	a)spring-boot-starter-web
	b)spring-boot-devtools
	c)tomcat-embed-jasper

2) Configure below properties in application.properties file
	a)Embedded Server Port
	b)View Resolver

3) Create Form Binding Class (Command Class)
4) Create Controller class with below methods
	a) Method to load the form
	b) Method to handle form submission
5) Create View file
6) Run the application and test it.
	
--------------------------------pom.xml--------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.5.1</version>
		<relativePath /> <!-- lookup parent from repository -->
	</parent>
	<groupId>in.ashokit</groupId>
	<artifactId>22-SB-Web-FormTags-App</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>war</packaging>
	<name>22-SB-Web-FormTags-App</name>
	<description>Demo project for Spring Boot</description>
	<properties>
		<java.version>1.8</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
			<scope>provided</scope>
		</dependency>

		<dependency>
			<groupId>org.apache.tomcat.embed</groupId>
			<artifactId>tomcat-embed-jasper</artifactId>
		</dependency>


		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>
-----------------------------ProductController.java------------------------------------------
package in.ashokit.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;

import in.ashokit.bindings.Product;

@Controller
public class ProductController {

	@GetMapping("/loadForm")
	public String loadForm(Model model) {

		Product pobj = new Product();

		model.addAttribute("product", pobj);

		return "index";
	}

	@PostMapping("/saveProduct")
	public String handleSaveBtnClick(Product product, Model model) {

		System.out.println(product);

		model.addAttribute("msg", "Product Saved Successfully");

		return "dashboard";

	}

}
----------------------------------index.jsp--------------------------------------------------
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
	pageEncoding="ISO-8859-1"%>

<%@ taglib uri="http://www.springframework.org/tags/form" prefix="form"%>

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>

	<h3>Product Form</h3>

	<form:form action="saveProduct" modelAttribute="product" method="POST">
		<table>
			<tr>
				<td>Product ID</td>
				<td><form:input path="productId" /></td>
			</tr>
			<tr>
				<td>Product Name</td>
				<td><form:input path="productName" /></td>
			</tr>
			<tr>
				<td>Product Price</td>
				<td><form:input path="productPrice" /></td>
			</tr>
			<tr>
				<td></td>
				<td><input type="submit" value="Save" /></td>
			</tr>
		</table>
	</form:form>
</body>
</html>
---------------------------------dashboard.jsp-------------------------------------------------
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<h2>${msg}</h2>

<a href="loadForm">Go Back</a>
</body>
</html>
---------------------------application.properties--------------------------------------------
server.port=9090

spring.mvc.view.prefix=/pages/
spring.mvc.view.suffix=.jsp
---------------------------------------------------------------------------------------------

Student Registration Form Development
-------------------------------------------------------------------------

1) Create Project with below dependencies

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.5.1</version>
		<relativePath /> <!-- lookup parent from repository -->
	</parent>
	<groupId>in.ashokit</groupId>
	<artifactId>23-SB-Web-Student-Reg-App</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>war</packaging>
	<name>23-SB-Web-Student-Reg-App</name>
	<description>Demo project for Spring Boot</description>
	<properties>
		<java.version>1.8</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.apache.tomcat.embed</groupId>
			<artifactId>tomcat-embed-jasper</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>com.oracle.database.jdbc</groupId>
			<artifactId>ojdbc8</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>
------------------------------------------------------------------------
2) Configure below properties in application.properties
-------------------------------------------------------------------------
server.port=9090

spring.mvc.view.prefix=/pages/
spring.mvc.view.suffix=.jsp

spring.datasource.url=jdbc:oracle:thin:@localhost:1521/XE
spring.datasource.username=IES_DEV
spring.datasource.password=IES_DEV
spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver

spring.jpa.show-sql=true
-------------------------------------------------------------------------
3) Create Entity classes (Course, Timings, Genders)
-------------------------------------------------------------------------
@Entity
@Table(name = "COURSES")
public class Courses {

	@Id
	@Column(name = "COURSE_ID")
	private Integer courseId;

	@Column(name = "COURSE_NAME")
	private String courseName;
}

@Entity
@Table(name = "GENDERS")
public class Genders {

	@Id
	@Column(name = "GENDER_ID")
	private Integer genderId;

	@Column(name = "GENDER_NAME")
	private String genderName;
}


@Entity
@Table(name = "TIMINGS")
public class Timings {

	@Id
	@Column(name = "TIMING_ID")
	private Integer timingId;

	@Column(name = "TIMING_NAME")
	private String timingName;
}
-------------------------------------------------------------------------
4) Create Repository Interfaces for tables
-------------------------------------------------------------------------
public interface CoursesRepository extends JpaRepository<Courses, Serializable> {
}

public interface GendersRepository extends JpaRepository<Genders, Serializable> {
}

public interface TimingsRepository extends JpaRepository<Timings, Serializable> {
}
-------------------------------------------------------------------------
5) Create Service Class
------------------------------------------------------------------------
Service
public class StudentService {

	@Autowired
	private GendersRepository gendersRepo;

	@Autowired
	private CoursesRepository coursesRepo;

	@Autowired
	private TimingsRepository timingsRepo;

	public List<String> getGenders() {
		List<Genders> findAll = gendersRepo.findAll();

		List<String> genders = new ArrayList<>();

		findAll.forEach(gender -> {
			genders.add(gender.getGenderName());
		});

		return genders;
	}

	public List<String> getCourses() {
		List<Courses> findAll = coursesRepo.findAll();

		List<String> courses = new ArrayList<>();
		findAll.forEach(course -> {
			courses.add(course.getCourseName());
		});

		return courses;
	}

	public List<String> getTimings() {
		List<Timings> findAll = timingsRepo.findAll();

		List<String> timings = new ArrayList<>();
		findAll.forEach(timing -> {
			timings.add(timing.getTimingName());
		});

		return timings;
	}
}
-------------------------------------------------------------------------
6) Create Form Binding Class
-------------------------------------------------------------------------
public class Student {

	private String name;
	private String email;
	private Long phno;
	private String gender;
	private String course;
	private String[] timings;
}
-------------------------------------------------------------------------
7) Create StudentController class
-------------------------------------------------------------------------
@Controller
public class StudentController {

	@Autowired
	private StudentService studentService;

	@GetMapping("/loadForm")
	public String loadRegForm(Model model) {

		model.addAttribute("genders", studentService.getGenders());
		model.addAttribute("courses", studentService.getCourses());
		model.addAttribute("timings", studentService.getTimings());

		Student sobj = new Student();

		model.addAttribute("student", sobj);

		return "index";
	}

	@PostMapping("/saveStudent")
	public String handleRegBtnClick(Student student, Model model) {

		System.out.println(student);

		model.addAttribute("msg", "Student Registered Successfully...!!");

		return "dashboard";
	}
}
-------------------------------------------------------------------------
8) Create View Files
------------------------------------------------------------------------
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
	pageEncoding="ISO-8859-1"%>

<%@ taglib uri="http://www.springframework.org/tags/form" prefix="form"%>

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>

	<h2>Student Registration Form</h2>

	<form:form action="saveStudent" modelAttribute="student" method="POST">

		<table>
			<tr>
				<td>Name</td>
				<td><form:input path="name" /></td>
			</tr>
			<tr>
				<td>Email</td>
				<td><form:input path="email" /></td>
			</tr>
			<tr>
				<td>Phno</td>
				<td><form:input path="phno" /></td>
			</tr>
			<tr>
				<td>Gender</td>
				<td><form:radiobuttons items="${genders}" path="gender" /></td>
			</tr>
			<tr>
				<td>Course</td>
				<td><form:select path="course">
						<form:options items="${courses}" />
					</form:select></td>
			</tr>
			<tr>
				<td>Timings</td>
				<td><form:checkboxes items="${timings}" path="timings" /></td>
			</tr>
			
			<tr>
				<td></td>
				<td><input type="submit" value="Register"/>
			</tr>
			
		</table>
	</form:form>

</body>
</html>
-------------------------------------------------------------------------
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
	pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
	<h2>${msg}</h2>

	<a href="loadForm">Go Back</a>
</body>
</html>
-------------------------------------------------------------------------

Form validations
------------------------------------------------------------------------

1) Create Spring Boot application with below dependencies

	a)spring-boot-starter-web
	b)spring-boot-starter-validation
	c)tomcat-embed-jasper
	d)spring-boot-devtools

2) Configure below properties in application.properties file

	a)server port
	b)view resolver

3) Create Form Binding class with validation annotations

4) Create Controller class with Required methods

	a) Method to load form
	b) Method to handle form submission

5) Create View Files With Presentation Logic
-------------------------------------------------------------------------
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.apache.tomcat.embed</groupId>
			<artifactId>tomcat-embed-jasper</artifactId>
		</dependency>


		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>
-------------------------------------------------------------------------
package in.ashokit.binding;

import javax.validation.constraints.Email;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.NotNull;

public class User {

	@NotEmpty(message = "Please enter username")
	private String uname;

	@NotEmpty(message = "Please enter password")
	private String pwd;

	@NotEmpty(message = "Please enter email")
	@Email(message = "Please enter valid email")
	private String email;

	@NotNull(message = "Please enter phno")
	private Long phno;

	
}
-------------------------------------------------------------------------
package in.ashokit.controller;

import javax.validation.Valid;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;

import in.ashokit.binding.User;

@Controller
public class UserController {

	@GetMapping("/user-form")
	public String loadUserForm(Model model) {

		User userObj = new User();
		model.addAttribute("user", userObj);

		return "index";
	}

	@PostMapping("/saveUser")
	public String saveUser(@Valid User user, BindingResult result, Model model) {

		if (result.hasErrors()) {
			return "index";
		}

		System.out.println(user);
		model.addAttribute("msg", "User saved successfully");
		return "dashboard";
	}

}
------------------------------------------------------------------------
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
	pageEncoding="ISO-8859-1"%>

<%@ taglib uri="http://www.springframework.org/tags/form" prefix="form"%>

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>

<style>
.error {
	color: red;
}
</style>

</head>
<body>

	<h3>User Form</h3>

	<form:form action="saveUser" modelAttribute="user" method="POST">

		<table>
			<tr>
				<td>Username:</td>
				<td><form:input path="uname" /></td>
				<td><form:errors path="uname" class="error" /></td>
			</tr>
			<tr>
				<td>Password:</td>
				<td><form:password path="pwd" /></td>
				<td><form:errors path="pwd" class="error" /></td>
			</tr>
			<tr>
				<td>Email:</td>
				<td><form:input path="email" /></td>
				<td><form:errors path="email" class="error" /></td>
			</tr>
			<tr>
				<td>Phone Number:</td>
				<td><form:input path="phno" /></td>
				<td><form:errors path="phno" class="error" /></td>
			</tr>

			<tr>
				<td><input type="submit" value="Save" /></td>
			</tr>
		</table>

	</form:form>


</body>
</html>
-------------------------------------------------------------------------
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
		<h3>${msg}</h3>
		
		<a href="user-form">Go Back</a>
</body>
</html>

----------------------------------------------------------------------------
Thymeleaf
------------------------------------------------------------------------
-> We are developing web based applications using Spring Web MVC Module

-> In Spring web mvc module we are using JSP as a presentation technology

-> Traditionally this JSP is the default choice for generating html files while building web based applications using java.

-> JSP is very matured technology

Some Important Points To Know About JSP
---------------------------------------
1) JSP is not a template engine it will not render web page directley on browser

2) JSP files will be converted into servlet to produce response on the browser
-------------------------------------------------------------------------
Thymeleaf
-------------------------------------------------------------------------
-> Thymeleaf is true template engine

-> Thymeleaf takes HTML file, parse it and then produce web content on browser directley

-> Thymeleaf is more like HTML

-> Using Thymeleaf we can display dynamic data in HTML files.

-> Spring Boot supports for Thymeleaf as a presentation technology

-> To work with thymeleaf in our project, we need to add below starter

	<dependency>
	  <groupId>org.springframework.boot</groupId>
	  <artifactId>spring-boot-starter-thymeleaf<artifactId>
	<dependency>
Note: We no need to do any other configurations to work with thymeleaf. Spring Boot will take care of all configurations required for thymeleaf

----------------------------------------------------------------------------------
Developing First Application Using Thmeleaf
-----------------------------------------------------------------------------------
1) Create Spring Boot application with below dependencies

		a)web starter
		b)thymeleaf starter
		c)devtools

2) Create Controller class with required methods

3) Create HTML file using Thymeleaf template

Note-1 : View Files(HTML) should be created in src/main/resources/templates
Note-2 : View extension will be .html only

4) Configure Server Port in application.properties file

5) Run the application and test it.
----------------------------------------------------------------------------------------------

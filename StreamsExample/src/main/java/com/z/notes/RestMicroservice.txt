RESTful Services :
------------------
 By using java we can develop several types of applications
		1) Standalone/Desktop application
		2) Web applications
		3) Distributed applications (webservices)

What is standlone application?
------------------------------
-> The application which runs in only one computer is called as Standlone application.
	Ex: Eclipse IDE, Calc, Notepad, Antivirus etc...

What is web application?
------------------------
-> The application whichs run over internet is called as Web application.
	Ex: gmail, facebook, linkdin, irctc, ashokit.in etc...
-> Multiple users can access web application at a time.
-> Web applications are used for customer 2 business communication (C2B)

what is distributed application?
--------------------------------
-> If one application is communicating with another application then it is called as Distributed application.
-> To re-use one application services in other applications we will develop Distributed applications.
	Ex:   Passport <----------> AADHAR
	      Ashok IT <----------> IBM      

What is Distributed application & why ?
-------------------------------------------------------------------------
-> If one application is communicating with another application then it is called as Distributed application.
-> With the help of distributed application we can re-use business services.
-> Distributed applications are meant for business to business communication.

		Passport app -----------> Aadhar app
		Makemytrip app ----------> Air Lines, Hotels, irctc..

-------------------------------------------------------------------------
-> To develop Distributed applications we will use Webservices.
-------------------------------------------------------------------------
What is Webservice?
-------------------------------------------------------------------------
-> Webservices is a distributed technology which is used to develop distributed applications with Intereoperability
-------------------------------------------------------------------------
What is Intereoperability?
-------------------------------------------------------------------------
Irrespective of the platform and irrespective of the programming language if applications are communicating then they are called as Intereoperable applications.
			Java <--------> .Net
			Python <-------> Salesforce
			Angular <------> Java
			Python <--------> Java
-------------------------------------------------------------------------
-> In distributed applications consumer & provider applications will exchange the data.
-> Provider application will decide input data structure & output data structure.

Note: The data which is exchanging between consumer and provider should be intereoperable.

-> XML, JSON and YML are universal data formats for exchanging data in webservices.

Note: In distributed applications we should not exchange the data in object format.
-------------------------------------------------------------------------

-> In Java we can develop distributed applications with Intereoperability in 2 ways
		1) Webservices (SOAP Webservices)
		2) RESTful Services

Distributed application architecture
------------------------------------------------------------------------
-> In distributed applications 2 actors will be available

		1) Provider App
		2) Consumer App

-> The application which is giving business services to other applications is called as provider application.
-> The application which is taking business services from other applications is called as consumer application.
-> Provider and consumer applications will exchange the data in intereoperable format.
-> XML, JSON and YAML are universal formats to exchange the data.
-> HTTP protocol will acts as mediator between Consumer and Provider to exchange the data.
-------------------------------------------------------------------------
-> Distributed applications can be developed in 2 ways

		1) SOAP Based Webservices (Outdated)
		2) Restful Services (Trending)

-> SOAP Webservices can be developed in 2 ways

		1) JAX-RPC api
		2) JAX-WS api

-> RESTFul services can be developed in 2 ways

		1) JAX-RS api
		2) Spring with REST (Trending)
-------------------------------------------------------------------------
RESTful Services Evolution
------------------------------------------------------------------------
-> Initially people used to develop distributed applications with intereoperablity using SOAP Webservices.
-> Over a period "Roy Fielding" identified some challenges to work with Soap webservices.
-> Roy Fielding provided some architecture principles to develop distributed applications with intereoperability.
-> If we develop our application by using "Roy Fielding" principles then our application is called "Restful service".
-------------------------------------------------------------------------
REST Architecture Principles
-------------------------------------------------------------------------
1) Unique Addressbility
2) Uniform Constraint Interfaces
3) Message Oriented Representation
4) Communication Stateless
5) HATEOS
-------------------------------------------------------------------------
-> In Rest API we can write several methods to perform distributed operations. Every method should have unique address. This is called as Unique Addressability.


public class IrctcRestApi{
       ("/ticket")
      public Ticket BookTicket();
       ("/status")
      public String getPnrStatus()
      ("/cancel")
      public String cancelTicket();
      ("/trains")
      public List<Train> getTrains();
}
-------------------------------------------------------------------------
-> All the methods which are available in Rest api should bind with HTTP Protocol methods. This is called Uniform Constraint Interfaces.

	GET Request ----> GET Method --------> @GetMapping
	POST Request ----> POST method ------> @PostMapping
        PUT Request -----> PUT method -------> @PutMapping
	DELETE Request --> DELETE method ----> @DeleteMapping

------------------------------------------------------------------------
-> Message Oriented Representation nothing but Provider and Consumer can exchange the data as per their requirement.
------------------------------------------------------------------------
-> Consumer request information should not be store at provider side. Every request should be treated as first request only. This is called communication stateless.
-----------------------------------------------------------------------
-> HATEOS stands for Hypermedia as an engine for application state. Provider should send data to consumer in hypermedia format.
------------------------------------------------------------------------
REST Architecture Principles
-------------------------------------------------------------------------
-> Roy Fielding provided Architecture principles to develop Restful services
1) Unique Addressability
2) Uniform Constraint Interfaces
3) Message Oriented Representation
4) Communication Stateless
5) HATEOS

-----------------------------------------------------------------------
Few Important Annotations We will Use in Spring With REST
-------------------------------------------------------------------------
@RestController : To represent java class as distributed component

@GetMapping : To bind our method to HTTP GET request
@PostMapping : To bind our method to HTTP POST Request
@PutMapping : To bind our method to HTTP PUT Request
@DeleteMapping : To bind our method to HTTP DELETE request

@RequestParam : To read query parameter from URL
@PathVariable : To read URI parameter/Path Parameter from URL

@RequestBody : To read data from Request Body sent by client
@ResponseBody : To represent data as response to client
-------------------------------------------------------------------------
Developing First REST API using Spring With REST
-------------------------------------------------------------------------
1) Create Spring Boot application with below dependencies
		a)spring-boot-starter-web
		b)spring-boot-devtools
2) Create Distributed Component Using @RestController
3) Write Required methods in Rest Controller and bind them to HTTP Protocol methods
4) Configure Server Port Number in application.properties file
5) Run the application and test it.

 Developing REST API and Testing Using PostMan
-------------------------------------------------------------------------
Today's session : REST API development
-----------------------------------------------------------------------
package in.ashokit.rest;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/rest1")
public class GreetRestController {

	@GetMapping
	public String getGreetMsg() { // http://localhost:9090/rest1/
		String msg = "Good Morning...!!";
		return msg;
	}

	@GetMapping("/wish") // http://localhost:9090/rest1/wish
	public String getWishMsg() {
		String msg = "All the best..!!";
		return msg;
	}

	@GetMapping("/quote") // http://localhost:9090/rest1/quote
	public String getQuote() {
		String msg = "Do or Die";
		return msg;
	}

}
------------------------------------------------------------------------
package in.ashokit.rest;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/rest2")
public class WelcomeRestController {

	/*@GetMapping("/welcome")
	public String getWelcomeMsg() { // http://localhost:9090/rest2/welcome
		String msg = "Welcome To Ashok IT..!!";
		return msg;
	}*/

	@GetMapping("/welcome")
	public ResponseEntity<String> getWelcomeMsg(){
		String msg = "Welcome To Ashok IT..!!";
		return new ResponseEntity<String>(msg, HttpStatus.OK);
	}
}

 URL Mapping & Http Methods
-------------------------------------------------------------------------
1) Unique Addressbility
2) Uniform Constraint Interfaces
3) Message Oriented Representation
4) Communication Stateless
5) HATEOS
------------------------------------------------------------------------
-> In REST api, every method should be binded to unique address. To achieve this we are writing URL pattern at class level and method level also.

-> Every REST API method should be binded to HTTP Protocol method So thatClients can easily access our REST API methods using HTTP Protocol.
-------------------------------------------------------------------------
-> ResponseEntity class we are using Construct response to client.
-> Using ResponseEntity class we can set "response body" and 
"http status code" for response.
------------------------------------------------------------------------
-> Consumer/Client application will send request to Provider/Resource application.
-> Provider/Resouce application will process the request and will send response to Consumer/Client with HTTP Status Code.
-> HTTP Status Codes will tell how that request got processed by server.

1xx - (100-199) Req info
2xx - (200 - 299 ) Success (ok)
3xx - (300 - 399) Redirect
4xx - (400 - 499) Client Error
5xx - (500 - 599) Server Error
----------------------------------------------------------------------------------
HTTP Protocol
---------------------------------------------------------------------------------
Http Protocol is divided into 2 parts

1) HTTP Request
2) HTTP Response

Http request & response structure
------------------------------------------------------------------------
Today's session : HTTP Protocol Methods
------------------------------------------------------------------------
-> Rest api methods should be binded to HTTP Protocol methods. 

	Get Request --------> @GetMapping
	Post Request -------> @PostMapping
	Put Request -------> @PutMapping
	Delete Request ----> @DeleteMapping

--------------------------------------------------------------------------------
HTTP GET Method
-------------------------------------------------------------------------------
-> If client wants to get data from rest api method, then that rest api method should be binded to get request using @GetMapping annotation.
-> GET Request will not contain request body
-> Clients can send data to rest api in the URL (query params & path Params) while sending GET request.

--------------------------------------------------------------------------------
HTTP POST Method
---------------------------------------------------------------------------------
-> If REST api method is responsible to create a new record with client given data then we will bind that method to HTTP Post Method using @PostMapping annotation.
-> HTTP Post Method will have request body.
-> Clients can send data to POST Request Method using
		1) Path Params
		2) Query Params
		3) Request Body

-> Simple and text data can be sent in URL and complex/secured/sensitive data should be sent in request body.
----------------------------------------------------------------------------------
HTTP PUT Request
----------------------------------------------------------------------------------
-> HTTP PUT method is used for updating the existing record
-> If client wants to update any existing record then we should bind our rest api method to HTTP PUT request using @PutMapping annotation
-> HTTP Put Request contains Request body.
-> Clients can send data to PUT Request Method using

		1) Path Params
		2) Query Params
		3) Request Body
-----------------------------------------------------------------------------------
HTTP DELETE
----------------------------------------------------------------------------------
-> HTTP DELETE method is responsible for deleting the record
-> If client wants to delete any record using rest api method, then we should bind that rest api method to DELETE request usign @DeleteMapping annotation.
-> HTTP DELETE will have Request Body.
-> Clients can send data to DELETE Request Method using

		1) Path Params
		2) Query Params
		3) Request Body
-----------------------------------------------------------------------------------
Summary
----------------------------------------------------------------------------------
-> What is HTTP Protocol ?
-> What HTTP methods we will use in REST API development
-> When to use which HTTP method
-> HTTP Request Structure
-> HTTP Response Structure
-> HTTP Status Codes
-> HTTP Status Messages


HTTP Protocol Methods
-------------------------------------------------------------------------
-> Below 4 methods we will use as part of REST api development
		1) GET Method  (Getting the data)
		2) POST Method (Creating record)
		3) PUT Method (Updating record)
		4) DELETE Method (Deleteing record)
-------------------------------------------------------------------------
1) What is Unique Addressability?
2) What is Uniform Constraint Interfaces?
-------------------------------------------------------------------------
Message Oriented Representation
-------------------------------------------------------------------------
-> Client app & Resource app can exchange the data as per their requirement.

Message Converters
-------------------------------------------------------------------------
-> We are using objects for rest api methods development.
-> Method parameter and method return type we are using as object.
-> If we use objects then our methods will be loosely coupled with format of data.

---------------------------------------------------------------------------------
@RestController
public class BookRestController {

	@GetMapping("/book")
	public Book getBookData() {
		Book b = new Book(101, "Spring", 450.00);
		return b;
	}
}
----------------------------------------------------------------------------------
Q-1) As the above rest api method is returning object, client will recieve that object or will not recieve that object?
Ans) Client will not recieve object bcz of intereoperability. Rest api side Message Converters will be available to convert object data into client understandable format.
Q-1) How Rest api will understand client expected format for response data?
Ans) Client should send "Accept" header with expected response format in the request.
	Accept = application/xml  (For xml response)
	Accept = application/json (For json response)
-----------------------------------------------------------------------------------
How Java Object Is Converted To Json ?
----------------------------------------------------------------------------------
-> To convert Java Object To Json format we have JACKSON api.
-> Jackson is a third party api which is getting used in Spring Boot.
-> MessageConverters will use Jackson api to deal with JSON data.
-> Using Jackson api we can convert java object to json and json to java obj.
----------------------------------------------------------------------------------
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
		</dependency>
----------------------------------------------------------------------------------
package in.ashokit;

import com.fasterxml.jackson.databind.ObjectMapper;

public class JavaToJsonConverter {

	public static void main(String[] args) throws Exception {

		Book book = new Book();
		book.setBookId(101);
		book.setBookName("Spring");
		book.setBookPrice(450.00);

		// convert book data into json
		ObjectMapper mapper = new ObjectMapper();
		String json = mapper.writerWithDefaultPrettyPrinter()
							.writeValueAsString(book);
		System.out.println(json);
	}

}
----------------------------------------------------------------------------------
How to convert Java object to XML format?
----------------------------------------------------------------------------------
-> To convert java object to xml format we will use JAX-B api.
-> JAX-B api is part of jdk. We no need to add any dependency for JAXB.
-> To convert java object into xml format, that java class should have @XmlRootElement annotation.
-----------------------------------------------------------------------------------
package in.ashokit;
import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement
public class Book {

	private Integer bookId;
	private String bookName;
	private Double bookPrice;
}
---------------------------------------------------------------------------------
package in.ashokit;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;

public class JavaToXmlConverter {
	public static void main(String[] args) throws Exception {
		Book b = new Book();
		b.setBookId(201);
		b.setBookName("Hibernate");
		b.setBookPrice(500.00);
		JAXBContext context = JAXBContext.newInstance(Book.class);
		Marshaller marshaller = context.createMarshaller();
		marshaller.marshal(b, System.out);
	}

}
----------------------------------------------------------------------------------

Message Converters
----------------------------------------------------------------------------------
-> Message Converters are used for converting object data to json/xml format and vice versa.
				jackson
		java object <------------> json	
				jax-b
		java object <-------------> xml

-> To work with JSON data in java applications we will use Jackson api. Jackson api is third party api.
-> To work with XML data in java applications we will use JAX-B api. It is part of JDK only.
----------------------------------------------------------------------------------
JSON Data Using Jackson api
---------------------------------------------------------------------------------
-> JSON stands for Java Script Object Notation
-> JSON will represent data in key-value format
-> JSON is platform independent and language independent
-> JSON is called as Intereoperable format
-> Now a days applications are using JSON format to exchange the data
Syntax:
{
   "id" : 101,
   "name" : "Ashok",
   "phno" : 6301921083
}

-> Jackson api provided ObjectMapper class to perform convertions
-> The process of converting Java object to JSON format is called as "Serialization"	
-> The process of converting JSON data to Java object is called as
 "De-Serialization"
-> To convert object data to json and json data to object we need class which represents structure of the JSON.

-----------------------------------------------------------------------------------
@Data 
@JsonInclude(value = Include.NON_NULL)
public class Book {
	@JsonProperty("bid")
	private Integer bookId;
	private String bookName;
	private Double bookPrice;
}
---------------------------------------------------------------------------------
package in.ashokit;
import com.fasterxml.jackson.databind.ObjectMapper;
public class JavaToJsonConverter {
	public static void main(String[] args) throws Exception {
		Book book = new Book();
		book.setBookId(101);
		book.setBookName("Spring");
		book.setBookPrice(450.00);
		// convert book data into json
		ObjectMapper mapper = new ObjectMapper();
		String json = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(book);
		System.out.println(json);
	}

}
---------------------------------------------------------------------------------
package in.ashokit;
import java.io.File;
import com.fasterxml.jackson.databind.ObjectMapper;
public class JsonToJavaConverter {
	public static void main(String[] args) throws Exception {
		File file = new File("Book.json");
		ObjectMapper mapper = new ObjectMapper();
		Book book = mapper.readValue(file, Book.class);
		System.out.println(book);
	}
}
-----------------------------------------------------------------------------------
{
	"bookName": "Spring",
	"bookPrice": 450.0,
	"bid": 101
}
---------------------------------------------------------------------------------
	String json writeValueAsString(Object) ---- converts obj to json
	Object readValue(File f, Class type) ---> converts json to obj
---------------------------------------------------------------------------------
XML Data with JAX-B Api
--------------------------------------------------------------------------------
-> XML stands for Extensible Markup Language
-> XML is platform independent and language independent
-> XML will represent data in in the form of elements
<person>
  <id>101</id>
  <name>Ashok</name>
  <phno>6301921083</phno>
</person>
-> To convert Java Object to xml and xml to java object we have JAX-B api.
-> The process of converting java obj to xml is called as "Marshalling"
-> The process of converting xml data to java obj is called as "Un-Marshalling"
-> To perform Marshalling and Un-Marshalling we need to have binding class
-> The java class which is representing stucture of xml is called as Binding class
-> To represent java class as Binding class we will use @XmlRootElement annotation.
---------------------------------------------------------------------------------
@XmlRootElement
public class Book {
	private Integer bookId;
	private String bookName;
	private Double bookPrice;
}
--------------------------------------------------------------------------------
package in.ashokit;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;

public class JavaToXmlConverter {

	public static void main(String[] args) throws Exception {
		Book b = new Book();
		b.setBookId(201);
		b.setBookName("Hibernate");
		b.setBookPrice(500.00);
		JAXBContext context = JAXBContext.newInstance(Book.class);
		Marshaller marshaller = context.createMarshaller();
		marshaller.marshal(b, System.out);
	}
}
-------------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<book>
	<bookId>201</bookId>
	<bookName>Hibernate</bookName>
	<bookPrice>500.0</bookPrice>
</book>
--------------------------------------------------------------------------------
package in.ashokit;

import java.io.File;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.Unmarshaller;

public class XmlToJavaConverter {
	public static void main(String[] args) throws Exception {
		JAXBContext context = JAXBContext.newInstance(Book.class);

		Unmarshaller unmarshaller = context.createUnmarshaller();
		Object object = unmarshaller.unmarshal(new File("Book.xml"));
		Book b = (Book) object;
		System.out.println(b);
	}
}
----------------------------------------------------------------------------------

Jackson and JAX-B api
-------------------------------------------------------------------------
-> Jackson api is used to convert java object to json and vice versa.
-> Any java class we can use with Jackson api.
-> JAX-B api is used to convert java object to xml and xml to java object.
-> Only binding class we can use with Jax-b api.
-> To represent our java class as binding class we will use @XmlRootElement.
-------------------------------------------------------------------------
-> The process of converting java object to json is called as Serialization.
-> The process of converting json data to java object is called as De-Serialization.

------------------------------------------------------------------------
-> The process of converting java object to XML is called as 'Marshalling'
-> The process of converting xml data to java object is called as Un-Marshalling.
-----------------------------------------------------------------------
-> "produces" attribute will represent data formats supporting by rest api method.
@GetMapping(value = "/customer", produces = { "application/json", "application/xml" })
	public Customer getCustomerData() {

		Customer customer = new Customer();
		customer.setCustomerId(101);
		customer.setCustomerName("Anil");
		customer.setCustomerPhno(6868686868l);
		return customer;

	}

-> Above method will support for both xml and json formats.
-> "Accept" header is used to reprsent in which format client expecting the response.
-> When client send a request with "Accept" header that value should match with produces value then only request can be processed otherwise it will return 406 Not acceptable.
-------------------------------------------------------------------------
Q) How client will know which formats supported for REST api method?
Ans) Rest api development team should provide documentation to client team.
Note: Now a days people are using Swagger for documentation.
-------------------------------------------------------------------------
Q) Can client send data to rest api using GET request?
Ans) Yes client applications can send data to GET request method using Query Parameters & URI Parameters (Path Parameters)
-> Query Parameters & URI Parameters will represent data in URL directley.
 Query Param : www.ashokit.in/courses?name=SBMS
 Path Param : www.ashokit.in/courses/SBMS
------------------------------------------------------------------------
How message converters works, produces and Accept
------------------------------------------------------------------------
-> MessageConverters are used to convert the data into intereoperable format
-> XML and JSON are universal formats to exchange the data among distributed applications.
-> "produces" attribute represents in which formats REST API method can produce the result
   @GetMapping(value="/url", produces= {"app/json", "app/xml"}
-> "Accept" header is used to specify in which format client expecting response from server.
		Accept = application/json
-------------------------------------------------------------------------
How client can send data to server Using GET Request
------------------------------------------------------------------------
-> Clients will use GET request to get data from REST API
-> GET Request will not contain body
-> If client wants to send some data to server then we can use below 2 approaches
	1) Query Parameter
	2) Path Parameter
------------------------------------------------------------------------
Query Parameters
-----------------------------------------------------------------------
-> Query Parameters are used to send data to server in the URL
-> Query Parameters will represent data in Key-Value format
-> Query Parameters will start with '?'
-> Query Parameters will be seperated by '&'
	Ex-1: www.ashokit.in/courses?name=SBMS
	Ex-2: www.ashokit.in/courses?name=SBMS&trainer=Ashok

Note: Query Parameters should present only at the end of the URL.
-----------------------------------------------------------------------
-> At REST API side we will use @RequestParam annotation to read query parameters from URL
	URL : www.ashokit.in/courses?name=SBMS
    public String getCourseDetails(@RequestParam String name){..}
-----------------------RequestParam-----------------------------------
package in.ashokit.rest;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class CourseRestController {

	@GetMapping(value = "/course")
	public String getCourseDetails(@RequestParam("name") String name) {
		String msg = "";
		if ("SBMS".equals(name)) {
			msg = "New Batch for SBMS From 15-Jul-2021 @8:00 PM IST";
		} else if ("JRTP".equals(name)) {
			msg = "New Batch For JRTP From 14-Jul-2021 @11:30 AM IST";
		} else if ("AWS".equals(name)) {
			msg = "New Batch For AWS From 13-Jul-2021 @7:00 PM IST";
		} else {
			msg = "Please visit www.ashokit.in for more details";
		}
		return msg;
	}

	@GetMapping(value = "/fee")
	public String getCourseFee(@RequestParam("cname") String cname, @RequestParam("tname") String tname) {
		String msg = cname + " By " + tname + " is 5000 INR Only";
		return msg;
	}

}
------------------------------------------------------------------------
Endpoint-1 URL : http://localhost:9090/course?name=AI
Endpoint-2 URL : http://localhost:9090/fee?cname=JRTP&tname=Ashok
-------------------------------------------------------------------------
Path Parameters
------------------------------------------------------------------------
-> Path Parameters also used to send data to server in the URL
-> Path Parameters are also called as URI parameters
-> Path Parameters can present anywhere in the URL
-> Path Parameters will start with '/' and will be seperated by '/' only
-> Path Parameters will represent the value directley
	Ex-1: www.ashokit.in/course/{SBMS}
	Ex-2: www.ashokit.in/course/{SBMS}/trainer/{Ashok}
-> At Rest api side we will use @PathVariable annotation to read Path Parameter value from URL

package in.ashokit.rest;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class CourseRestController {

	@GetMapping("/course/{cname}/trainer/{tname}")
	public String getCourseDetails(@PathVariable String cname, @PathVariable String tname) {
		String msg = cname + " By " + tname + " Starting From 15-Jul-2021 @8:00 PM IST";
		return msg;
	}
}

Path Parameters & Query Parameters
------------------------------------------------------------------------
-> Clients will use Path Parameters and Query Parameters to send the data to server in URL.
-> Query Params will represent data in key-value format
-> Path Params will represent data directley in URL
-> In C 2 B (Customer To Business) applications we will use Query Params
-> In B 2 B (Business To Business) applications we will use Path Params.
-------------------------------------------------------------------------
Challenges with Path Params & Query Params
------------------------------------------------------------------------
-> Data Will Be Exposed in URL
- Not recommended to send sensitive data
-> Bindary Data we can't send
-> URL length limitation  (2038 characters)
------------------------------------------------------------------------
Note: If we want to send any non-sensitive and small info to server then we can use Path Params & Query Params.
------------------------------------------------------------------------
-> To overcome the limitations of Path Params & Query Params we will use Request Body to send data to server.
Note: GET request doesn't have body. POST , PUT and DELETE requests are having request body.
-------------------------------------------------------------------------
HTTP POST Request
-------------------------------------------------------------------------
-> Http POST method is used to create a new record/resource at server
-> To bind our method to HTTP post request we will use @PostMapping
-> For POST request method client can send data in request body
-------------------------------------------------------------------------
import javax.xml.bind.annotation.XmlRootElement;
@XmlRootElement
public class User {
	private Integer uid;
	private String fname;
	private String lname;
	private String email;
	public User() {
		System.out.println("User::Constructor");
	}

	
}
-----------------------------------------------------------------------
package in.ashokit.rest;

import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import in.ashokit.bindings.User;

@RestController
public class UserRestController {

	@PostMapping(
			value = "/user",
			consumes = { "application/json", "application/xml" },
			produces = { "text/plain" }
	)
	public String addUser(@RequestBody User user) {
		System.out.println(user);
		String msg = "User Saved Successfully..";
		return msg;
	}
}
------------------------------------------------------------------------
{
    "uid" : 101,
    "fname" : "Ashok",
    "lname" : "IT",
    "email" : "ashokit@gmail.com"
}
---------------------------------------------------------------------
<user>
	<uid>102</uid>
	<fname>Ashok</fname>
	<lname>IT</lname>
	<email>ashokit@gmail.com</email>
</user>
-------------------------------------------------------------------------

Consumes & Content-Type
------------------------------------------------------------------------
-> "consumes" attribute will represent in which format rest api method can take the input data.
-> "Content-Type" header is used to represent in which format client is sending data to server in request body.
------------------------------------------------------------------------
1) produces : Represent method supporting response formats
2) Accept : Represents client expecting response format
3) consumes : Represent method supporting request formats
4) Content-Type : Represents client sending request format
------------------------------------------------------------------------
Procedure to follow to develop REST API
---------------------------------------------------------------------------------------------
1) Understand the requirement
2) Decide consumes & produces formats
3) Decide Endpoint input data structure
4) Decide Endpoint output data structure
5) Create Request Binding classes based on input data structure
6) Create Response Binding classes based on output data structure
7) Create Rest Controller with Endpoint method
8) Test endpoint behaviour using Postman

REST API Implementation process
--------------------------------------------------------------------------------------------------request-data-----------------------------------
{
	
"name" : "Ashok",
 "dob" : "20-May-1991",
 "gender" : "M",
 "doj" : "20-Jul-2021",
 "from" : "Hyd",
 "to" : "Pune",
 "train" : 1356

}
---------------------------response-data---------------------------------
{
    "name": "Ashok",
    "dob": "20-May-1991",
    "gender": "M",
    "doj": "20-Jul-2021",
    "from": "Hyd",
    "to": "Pune",
    "train": "1356",
    "status": "CONFIRMED",
    "price": 1500.09
}
-----------------
How HTTP Post request working  internally
-----------------------------------------------------------------------
1) DispatcherServlet process
2) HandlerMapper
3) HttpMsgBodyReader
4) HttpMsgBodyWriter
5) MessageConverters
6) consumes
7) produces
8) Content-Type
9) Accept
-------------------------------------------------------------------------
-> We understood What is HTTP GET request ?
-> We understood what is HTTP POST request ?
------------------------------------------------------------------------
-> If rest api method is responsible to provide data to client then we will bind our method to HTTP GET request using @GetMapping annotation.
-> HTTP GET request will not have any request body
-> If client wants to send some data to rest api GET request method then client will use Query Parameters & Path Parameters
-------------------------------------------------------------------------
-> If REST api method is responsible to create a new record/resource at server then we will bind our method to HTTP POST request using @PostMapping annotation.
-> HTTP Post request will have request body
-> Client can send data to HTTP POST Request method using Request Body.
-> HTTP Request Methods will return status code as "201 Created"
--------------------------------------------------------------------------------
-> By default DispatcherServlet will decide HTTP Status code and will send to client.
-> If we want to customize Http status code for our method we can use ResponseEntity.
Syntax :    ResponseEntity(T body, HttpStatus status)
Ex:	    new ResponseEnity(ticketResObj, HttpStatus.CREATED);

------------------------------------------------------------------------
HTTP PUT Request
----------------------------------------------------------------------------------
-> If our REST API method is responsible to update an existing record then we will bind our method to HTTP PUT Request Method.
-> HTTP PUT Request method contains Request body.
@PutMapping
public ResponseEntity<String> updateTicket(@RequestBody Ticket request){
	//logic to update the ticket

	return new ResponseEntity<>(body, HttpStatus.OK);
}
---------------------------------------------------------------------------------
HTTP DELETE Request
-> If our REST API method is responsible for deleting a record then we will bind that method to HTTP DELETE Request using @DeleteMapping annotation.

-> HTTP DELETE request contains Request Body
@DeleteMapping("/delete/{empId}")
public String deleteEmp(@PathVariable Integer empId){
	//logic to delete record
      return "Record Deleted";
}

Put Request & Delete Request
---------------------------------------------------------------------------------------------
-> If our rest api method is responsible to update existing record then we will bind our method to PUT request method using @PutMapping annotation.
-> If our rest api method is responsibel to delete existing record then we will bind our method to DELETE request method using @DeleteMapping.
-> Both PUT and DELETE requests having request body.
---------------------------------------------------------------------------------------------
1) Collect Requirements from functional team
2) Analyze the requirements
3) Analyze Risk Factor
4) Decide Input and Output Formats (Consumes & Produces)
5) Design Request Binding Classes
6) Design Response Binding Classes
7) Create Rest Controller with Endpoint method(s)
8) Implement Business logic
9) Test api functionality using POSTMAN
---------------------------------------------------------------------------------------------
REST Documentation
---------------------------------------------------------------------------------------------
-> REST APIs we are developing for business to business communications (B 2 B).
-> REST Apis are distributed applications with intereoperability.
-> When we are developing distributed applications one application will act as Resource Application and another application will act as client application.
	Client App (Consumer) <-----------------------> Resource App (Provider)
-> If client wants to access our API they should know details of our api.
-> Resource App development team should provide API documentation to Client App development team.
-> API documentation should contain below details
		1) Endpoint URL
		2) Request Method
		3) consumes formats
		4) produces formats
		5) Request data structure
		6) Response data structure

-> Swagger is one of the famous software which is used to generate REST API documentation.
-> Swagger UI is providing user interface for testing REST APIs.
----------------------------------------------------------------------------------------------
 Swagger Configuration
------------------------------------------------------------------------
-> When we develop REST API we should provide documentation of that API to client team.
-> REST Documentation should contain below details
		1) Endpoint URL	
		2) Request Method Type
		3) Request Media Types (Consumes)
		4) Response Media Types (Produces)
		5) Request Data Structure
		6) Response Data Structure

-> In order to provide REST Documentation we will use Swagger.
-> Swagger is an open source software which is used to generate documentation for REST API.
-> Swagger UI providing user interface to test our REST API.
----------------------------------------------------------------------------------
Configuring Swagger In Rest API
---------------------------------------------------------------------------------
1) Add below 2 dependencies in pom.xml file
		<dependency>
			<groupId>io.springfox</groupId>
			<artifactId>springfox-swagger2</artifactId>
			<version>2.8.0</version>
		</dependency>
		<dependency>
			<groupId>io.springfox</groupId>
			<artifactId>springfox-swagger-ui</artifactId>
			<version>2.8.0</version>
			<scope>compile</scope>
		</dependency>
2) Create SwaggerConfig class like below

@Configuration
@EnableSwagger2
public class SwaggerConfig {
	@Bean
	public Docket apiDoc() {
		return new Docket(DocumentationType.SWAGGER_2)
				   .select()
				   .apis(RequestHandlerSelectors.basePackage									("in.ashokit.rest"))
				   .paths(PathSelectors.any())
				   .build();
	}
}

-> Once above 2 steps are completed then we can access Swagger Documentation and Swagger UI using below URLS
	Documentation : http://localhost:9090/v2/api-docs
	Swagger UI : http://localhost:9090/swagger-ui.html

REST Client
------------------------------------------------------------------------
1) What is Rest Client?
Ans) Any program which is capable of sending http request to server is called as Rest Client
Note: Any body can act as client for Rest api
	1) Browser
	2) POSTMAN
	3) Swagger UI
	4) Program
------------------------------------------------------------------------
-> By using Spring mvc we can develop Rest Client in 2 ways
		1) RestTemplate
		2) WebClient
-> RestTemplate is a predefined class which supports for Synchronus communication. This is old approach.
-> Synchronus means after making a request it will wait for response.
-> WebClient got introduced in Spring 5.x version. It supports both Synchronus and Asynchronus communications. It is trending in the market.
-> Asynchronus means after making a request without waiting for response it will continue its execution.
-----------------------------------------------------------------------
-> In order to start rest client development we should know API details
-> API team will provide API documentation to client team using Swagger.
-> Client side team should understand API documentation and start client development based on documentation

Rest Client Introduction
-------------------------------------------------------------------------------------------
-> The application which is accessing business services from other applications is called as Client application.
-> In order to access business services we will develop Rest Client
-> Using Spring we can develop Rest client in 2 ways
		1) RestTemplate (Sync) - Outdated
		2) WebClient (Sync & Async)
-------------------------------------------------------------------------------------------
-> In order to develop REST Client we need to know API details like below
		1) Endpoint URL
		2) Request Method Type
		3) Consumes
		4) Produces
		5) Input Data Structure
		6) Output Data Structure
-------------------------------------------------------------------------------------------
API URL : https://quoters.apps.pcfone.io/api/random

Request Method : GET

consumes : N/A
produces : application/json

Request data structure : N/A
Response data structure : 
{
    "type": "success",
    "value": {
        "id": 11,
        "quote": "I have two hours today to build an app from scratch. @springboot to the rescue!"
    }
}
-------------------------------------------------------------------------------------------
 RestTemplate details
------------------------------------------------------------------------
-> RestTemplate is a pre-defined class available in Spring Web MVC module
-> Using RestTemplate we can send Http Request to server (Synchronus)
-> After Making a Request to Server, RestTemplate will wait for response to continue its execution.
-> RestTemplate provided several methods to send Http Request to server
RestClient development using RestTemplate for United Flights API
------------------------------------------------------------------------------
United Flights API Details
--------------------------------------------------------------------------------
Endpoint URL : http://mu.mulesoft-training.com/essentials/united/flights/

Request Method : GET

consumes: NA

produces : application/json

Input : NA

Output : Flights Info in Json format
---------------------------------------------------------------------------------
Rest Client Development For United Flights API
-----------------------------------------------------------------------
-> In order to develop Rest Client we need below details
	1) API URL
	2) Request Method
	3) API consumes formats
	4) API produces formats
	5) API Input data structure
	6) API output data structure

-> API team will provide all these details using swagger or pdf document.
How to send headers in request & exchange method
------------------------------------------------------------------------
-> To set headers to the request we will use HttpHeaders class
-> To add Headers to the request we will uses HttpEntity class
		HttpHeaders headers = new HttpHeaders();
			headers.set(key1,value1);
			headers.set(key2,value2);

		HttpEntity entity = new HttpEntity(body,headers);

		rt.exchange(Url, Method, entity, type);
-------------------------------------------------------------------------
-> Now a days people are not using RestTemplate bcz Spring itself saying to use WebClient
-> RestTemplate introduced in Spring 3.0 and WebClient introduced in Spring 5.0
-> RestTemplate supports only synchronus communication where as WebClient supports both Sync and Async communication.
------------------------------------------------------------------------
Q) What is Synchronus Communication?
------------------------------------
-> After making the request if our thread is waiting for the response to continue its execution then it is called as Sync communication.

Q) What is Asynchronus Communication?
------------------------------------
-> After making the request if our thread will continue its execution without waiting for the response then it is called as Aync communication.
------------------------------------------------------------------------
-> RestTemplate class is part of spring-boot-starter-web dependency where as WebClient is part of spring-boot-starter-webflux dependency

WebClient
------------------------------------------------------------------------
-> WebClient got introduced in Spring 5.x version
-> Using WebClient api we can develop rest clients
-> Webclient supports for both Synchronus and Asynchronus communication
-> To use WebClient in our application we have to add below dependency in pom.xml file

	spring-boot-starter-webflux   (Reactive Web)
	WebClient webClient = WebClient.create( );
	String response = webClient.get( )
			 .uri(endpointUrl)
			 .retrieve( )
			 .bodyToMono(String.class)
			 .block( );

	    //further logic to deal with response
 POST Request using WebClient, Sending Headers Using WebClient
----------------------------------------------------------------------------------------------
-> What is WebClient?
-> What is Sync request?
-> What is Async request?
-> How to send GET request using WebClient?
-> How to send POST request using WebClient?
-> What is block ( ) method ?
-> What is subscribe( ) method ?
-> How to send headers using Webclient?
---------------------------------------------------------------------------------------------
WebClient webclient = WebClient.create( );

		webclient.get( )
			 .uri( )
			 .accept(MediaType.APPLICATION_JSON)
			 .retrieve( )
			 .bodyToMono(Class clz)
			 .block( )

					
		webclient.post()
			 .uri( )
			 .contentType(MediaType.APPLICATION_JSON)
			 .accept(MediaType.APPLICATION_JSON)
			 .body(requestObj, Class clz)
			 .retrieve( )
			 .bodyToMono(Class clz)
			 .block( )
----------------------------------------------------------------------------------------------
What is Mono object and What is Flux object?
----------------------------------------------------------------------------------------------
-> Mono is used to represent single object
-> Flux is used to represent stream of objects
----------------------------------------------------------------------------------------------
import java.time.Duration;
import java.util.Date;
import java.util.stream.Stream;

import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import com.ashokit.domain.CustomerEvent;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;

@RestController
public class CustomerRestController {

	@GetMapping(value = "/getEvent", produces = "application/json")
	public ResponseEntity<Mono<CustomerEvent>> getCustomerEvent() {

		CustomerEvent event = new CustomerEvent("John", new Date());

		Mono<CustomerEvent> customerMono = Mono.just(event);

		ResponseEntity<Mono<CustomerEvent>> responseEntity = new ResponseEntity<Mono<CustomerEvent>>(customerMono,
				HttpStatus.OK);

		return responseEntity;
	}

	@GetMapping(value = "/getEvents", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
	public ResponseEntity<Flux<CustomerEvent>> getCustomerEvents() {

		// Creating Pojo object with data
		CustomerEvent event = new CustomerEvent("Smith", new Date());

		// Creating Stream object to send data
		Stream<CustomerEvent> customerStream = Stream.generate(() -> event);

		// Giving Stream object to Flux object
		Flux<CustomerEvent> ceFlux = Flux.fromStream(customerStream);

		// Setting Response Interval
		Flux<Long> interval = Flux.interval(Duration.ofSeconds(3));

		// Combining IntervalFlux and CustomerEventFlux
		Flux<Tuple2<Long, CustomerEvent>> zip = Flux.zip(interval, ceFlux);

		// Getting Second Tuple value as Flux Obj
		Flux<CustomerEvent> fluxMap = zip.map(Tuple2::getT2);

		// Adding Flux Object to Response Body
		ResponseEntity<Flux<CustomerEvent>> resEntity = new ResponseEntity<Flux<CustomerEvent>>(fluxMap, HttpStatus.OK);

		// Returning ResEntity with Flux
		return resEntity;
	}
}
-----------------------------------------------------------------------------------------------
public class CustomerEvent {
	private String customerName;
	private Date date;
	public CustomerEvent(String customerName, Date date) {
		this.customerName = customerName;
		this.date = date;
	}
}
----------------------------------------------------------------------------------------------
package com.tekleads.service;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClient.Builder;
@Service
public class CustomerEventService {
	private String REST_URL1 = "http://localhost:9090/getEvent";
	private String REST_URL2 = "http://localhost:9090/getEvents";
	public void invokeCustomerEvent() {
		Builder builder = WebClient.builder();
		WebClient webClient = builder.build();
		
		String eventResponse = webClient.get()
										 .uri(REST_URL1)
										 .retrieve()
										 .bodyToMono(String.class)
										 .block();
		System.out.println(eventResponse);
	}
	
	public void invokeCustomerEvents() {
		Builder builder = WebClient.builder();
		WebClient webClient = builder.build();
		webClient.get()
				 .uri(REST_URL2)
				 .retrieve()
				 .bodyToFlux(String.class)
				 .subscribe(System.out::println);
	}
}
-------------------------------------------------------------------------------------------
Mono and Flux object
-------------------------------------------------------------------
-> Mono and Flux are reactive components
-> Reactive programming got introduced in Spring 5.x version
-> Reactive programming means Event Driven Programs.
-> We will execute our program based on some events.
-> To represent single object we will use Mono
-> To represent stream of objects we will use Flux
--------------------------------------------------------------------
1) what is application.yml file
2) Actuators in Spring Boot
-------------------------------------------------------------------
Today's session : application.yml  file
-------------------------------------------------------------------
-> When we create Spring Boot application we will get below file by default in src/main/resources folder
	  application.properties

-> We will configure properties in the form of key-value pair in application.properties file which are required for our application
-> Below are some properties which we will configure in our properties file
		1) DataSource props
		2) Server Port
		3) View Resolver
		4) Actuators props
		5) Kafka Props
		6) Redis Cache props
		7) Security Props
		8) Application Messages etc.
-> To configure above properties we can use application.yml file also
-> YML or YAML stands for YET ANOTHER MARKUP LANGUAGE
-> Now a days in boot applications we are using YML files for configuring properties instead of application.properties file
-> .yml files are more readable when compared with .properties files
--------------------------------------------------------------------------------------
spring:
  datasource:
    driver-class-name: oracle.jdbc.driver.OracleDriver
    password: IES_DEV
    url: jdbc:oracle:thin:@localhost:1521/XE
    username: IES_DEV
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
-------------------------------------------------------------------------------------
-> If you already have .properties file then we can convert that file into .yml file (Right click on .properties file -> convert to .yml file)
--------------------------------------------------------------------------------------
How to read yml file data into java class to avoid hard coding
-------------------------------------------------------------------------
-> In realtime applications we need to display several messages like success and failure messages
-> In Realtime applications we will use several third party api urls
-> We should not hard code the messages and URLs in our java program
-> To avoid this hard coding we will use these yml files.
-------------------------------------------------------------------------
server:
  port: 9090
app: 
  messages:
    greetMsg: Good Morning..!!
    welcomeMsg: Welcome to Ashok IT..!!
-------------------------------------------------------------------------
package in.ashokit.props;

import java.util.HashMap;
import java.util.Map;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableConfigurationProperties
@ConfigurationProperties(prefix = "app")
public class AppProperties {

	private Map<String, String> messages = new HashMap<>();

	public Map<String, String> getMessages() {
		return messages;
	}

	public void setMessages(Map<String, String> messages) {
		this.messages = messages;
	}

}
-------------------------------------------------------------------------
package in.ashokit.rest;

import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import in.ashokit.props.AppProperties;

@RestController
public class WelcomeRestController {

	@Autowired
	private AppProperties appProps;

	@GetMapping("/welcome")
	public String welcomeMsg() {
		Map<String, String> msgs = appProps.getMessages();
		String msgValue = msgs.get("welcomeMsg");
		return msgValue;
	}

	@GetMapping("/greet")
	public String greetMsg() {
		Map<String, String> msgs = appProps.getMessages();
		String greetVal = msgs.get("greetMsg");
		return greetVal;
	}
}
-------------------------------------------------------------------------
Actuators in Spring Boot
------------------------------------------------------------------------
-> Actuator is one of the powerful concept provided by Spring Boot
-> Actuators are used get production ready features of the application

Actuators
-------------------------------------------------------------------------
-> Actuators are used to provide production ready features of our application.
-> Actuators will allow us to interact with application.
-> Using Actuators we can monitor and manage our application.
-> To work with Actuators we need to add below starter in pom.xml file
		spring-boot-starter-actuator

-> To see the actuators which are exposed for our application we can use below url
		http://localhost:9090/actuator
-> We can expose and exclude actuator endpoints using .properties file and .yml file.
server:
  port: 9090
management:
  endpoints:
    web:
      exposure:
        include: '*'
        exclude: beans, mappings

-> All the actuator endpoints are binded to HTTP GET Request.
------------------------------------------------------------------------
-> We have shutdown endpoint in Actuator which is very special.
-> shutdown endpoint is used to stop the application.
-> Shutdown is special endpoint and it is binded to HTTP POST Request
server:
  port: 9090
management:
  endpoints:
    web:
      exposure:
        include: '*'
        exclude: beans, mappings
  endpoint:
    shutdown:
      enabled: true

Note: After enabling shutdown endpoint, send post request using POSTMAN. It will stop our application.
-------------------------------------------------------------------------

-> ROY Fielding Provided Rest Architecture principles
	1) Unique Addressability
	2) Uniform Constraint Interfaces
	3) Message Oriented Representation
	4) Communication Stateless
	5) HATEOS

---------------------------------------------------------------------------------
-> Hypermedia as the Engine of Application State (HATEOAS).
-> It is a constraint of the REST application architecture that distinguishes it from other network application architectures.
-> With HATEOAS, a client interacts with a network application whose application servers provide information dynamically through hypermedia.
Ex: When we search for something in google, it will provide response in hyperlinks format that means it is following HATEOS principles
---------------------------------------------------------------------------------
-> Client made a request to REST api to get Student information.
-> Student REST api provided response in below format.
{
   "sid" : '09-SBMS-101',
   "sname" : "Raju",
   "srank" : 198,
   "links" : {
            'http://www.ashokit.in/student/09-SBMS-101/address' 
     }
}
---------------------------------------------------------------------------------
package com.ashokit.binidings;
import org.springframework.hateoas.RepresentationModel;
public class Book extends RepresentationModel<Book> {
	private String isbn;
	private String name;
	private Double price;
	private String author;

	public Book() {
		// TODO Auto-generated constructor stub
	}

	public Book(String isbn, String name, Double price, String author) {
		super();
		this.isbn = isbn;
		this.name = name;
		this.price = price;
		this.author = author;
	}

}
---------------------------------------------------------------------------------
package com.ashokit.rest;

import java.util.ArrayList;
import java.util.List;

import org.springframework.hateoas.Link;
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

import com.ashokit.binidings.Book;
@RestController
public class BookRestController {
	@GetMapping(value = "/book/{isbn}", produces = "application/json")
	public Book getBookInfo(@PathVariable("isbn") String isbn) {

		Book b = new Book(isbn, "Spring", 300.00, "Rod Johnson");
		
		Link withRel = 
				WebMvcLinkBuilder.linkTo(WebMvcLinkBuilder.methodOn(BookRestController.class)
														  .getAllBooks())
   			   .withRel("All-Books");
		
		b.add(withRel);
		
		return b;
	}

	@GetMapping(value="/books", produces="application/json")
	public List<Book> getAllBooks() {
		
		Book b1 = new Book("ISBN001", "Spring", 300.00, "Rod Johnson");
		Book b2 = new Book("ISBN002", "Spring Boot", 400.00, "Rod Johnson");
		Book b3 = new Book("ISBN003", "Spring Cloud", 200.00, "Rod Johnson");

		List<Book> books = new ArrayList<Book>();
		books.add(b1); 
		books.add(b2);
		books.add(b3);
		
		return books;
	}
}
----------------------------------------------------------------------------------
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-hateoas</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
			<exclusions>
				<exclusion>
					<groupId>org.junit.vintage</groupId>
					<artifactId>junit-vintage-engine</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
	</dependencies>
---------------------------------------------------------------------------------
HATEOS
------------------------------------------------------------------------
-> HATEOS is one of the REST architecture principle given by roy fielding
-> HATEOS stands for Hyper media as engine for application state
-> When client send request to server, then server will process the request and will send response to client in hyper media format
------------------------------------------------------------------------
Part-1 : Spring Boot Internals - Completed
Part-2 : Spring Data JPA - Completed
Part-3 : Spring Web MVC - Completed
Part-4 : Spring With REST (Resful Services) - Completed
Part-5 : Microservices (Getting Started Today)
------------------------------------------------------------------------
Today's session : Microservices
--------------------------------------------------------------------------------
-> Now a days java is mainley using to develop web applications only
-> We can develop web applications in 2 ways
		1) Monolith Architecture
		2) Microservices Architecture
---------------------------------------------------------------------------------
What is Monolith Architecture?
---------------------------------------------------------------------------------
-> If we develop all the functionalities in one single application then we will call it as Monolith Architecture based application.
-> When we package our application we will get one war file.
-> Monolith application war files are called as fat war files or heavy weight war files
-> It is very difficult to manage and maintain fat war files
Advantages
----------
1) Implementation will be easy
2) Bug Tracking/Debugging Will be easy
3) Better throughput

Dis-Advantages
---------------
1) Tighthly coupling among the components
2) Less Scalability
3) Burden on server
4) Deployment process will be difficult
5) Load Balancing is difficult & challenging
----------------------------------------------------------------------------------
-> To avoid the problems of Monolith Architecture, Microservices Architecture Came into picture.
----------------------------------------------------------------------------------
What is Microservices ?
----------------------------------------------------------------------------------
-> Microservices is not a programming language
-> Microservices is not a technology
-> Microservices is not a framework
-> Microservies is not an API
-> Microservices is a design pattern which is used to develop our application functionalities with loosely coupling.
-> Microservices architecture is not specific to any technology. 
----------------------------------------------------------------------------------
Challenges with Microservices
----------------------------------------------------------------------------------
1) Bounded Context
2) Boiler Plate Configuration
3) Visibility
4) Pack of cards problem
----------------------------------------------------------------------------------
-> Bounded Context means deciding boundary for rest api is very difficult. How many rest apis we need to develop for given requirements ? deciding this is difficult task.
-> In every REST api we have to write same configurations
		1) DB Config
		2) Security Config
		3) Actuator Config
		4) Redis Config
		5) Kafka Config
-> All the developers will not have visibility on all the apis available in project.
-> Pack of cards problem means if any important microservice failed then request can't be processed.
----------------------------------------------------------------------------------
Advantages of Working with Microservices
---------------------------------------------------------------------------------
1) Easy Maintenence
2) Scalability
3) Technology Independence
4) Easy Deployment
----------------------------------------------------------------------------------
Microservices Architecture
----------------------------------------------------------------------------------
-> There is no fixed architecture for Microservices development
-> People are customizing microservices architecture as per their requirement.
Note-1 : We will discuss about generalized architecture for Microservices development which is using by most of the projects in the industry.
Note-2: In one company 2 different projects might use 2 different approaches to develop Microservices based applications.
-----------------------------------------------------------------------------------
 Microservices Architecture
---------------------------------------------------------------------------------
-> Microservices is a design pattern which is used to develop the applications with loosely coupling.
-> Microservices is not specific to any technology.
-> We don't have any fixed architecture for Microservices.
-> People are customizing microservices architecture as per their requirement.
---------------------------------------------------------------------------------
Service Registry
---------------------------------------------------------------------------------
-> Service Registry is used to register all the services(apis) available in application.
-> We can use Eureka Server as Service Registry for our apis.
-> Spring Cloud Netflix libraries provided Eureka Server for us.
Steps to develop Service Registry Application
----------------------------------------------
-> Create Spring Starter Project with below dependencies
	1) spring-cloud-starter-netflix-eureka-server
	2) spring-boot-devtools
-> Enable Eureka Server in boot start class using @EnableEurekaServer annotation
-> Configure below properties in application.yml file
server:
   port: 8761
eureka:
  client:
    register-with-eureka: false

-> Start the application and access Eureka dashboard using below URL

		http://localhost:8761/


What is Service Registry ?
----------------------------------------------------------------------------------
-> Service Registry is an API which is used to register all the apis available in our application.
-> If we register our apis with service registry then we can monitor all our apis and apis details at one place.
-> Eureka Server we can use as Service Registry for our Microservices architecture based application.
-> Spring Cloud Netflix Libraries provided Eureka Server for us
-> To enable Eureka Server in our application we will use @EnableEurekaServer annotation
---------------------------------------------------------------------------------
-> In our application we will develop several APIs
-> API is also called as Service
-> The API which is registered with Eureka Server is called as Eureka Client or Discovery Client
-> To represent our API as Eureka client application we will use @EnableDiscoveryClient annotation
-> If Eureka Server is running on same machine with 8761 port then our API will auto-register with Eureka Server.
-> If we want to register our api with Eureka Server manually then we need to configure below property in application.yml file
eureka:
  client:
    service-url:
      defaultZone: ${DISCOVERY_URL:http://localhost:9090}/eureka/

-> We will configure name for our API using below property
spring:
  application:
    name: GREET-API

Note: This name will be displayed in Eureka Dashboard once our API got registered with Eureka Server.
----------------------------------------------------------------------------------
-> What is Interservice Communication ?
---------------------------------------------------------------------------------
-> If one API is communicating with another api which are belongs to same application then it is called as Inter service communication.
FeignClient For Interservice Communication
----------------------------------------------------------------------------------
-> In Microservices Architecture based application, we will develop several REST apis.
-> As part of application execution, one rest api will communicate with another rest api. This is called as Interservice Communication.
-> To achieve Interservice Communication we can use FeginClient.
-> FeginClient provided by Spring Cloud Netflix library.
----------------------------------------------------------------------------------
1) Add Feign client dependency in pom.xml file
2) Write @EnableFeignClients dependency at boot start class
3) Creat Fegin Client component like below to access other api
-------------------------------------------------------------------------------
@FeignClient(name = "GREET-API")
public interface GreetClient 
	@GetMapping("/greet")
	public String invokeGreetApi();
}
----------------------------------------------------------------------------------
-> GREET-API is name of the api which is registered in Eureka Server
-> @GetMapping("/greet) representing that GREET-API having endpoint method with GET request and url-pattern is "/greet".
-> When we call invokeGreetApi() method, FeignClient will get GREET-API url from service registry based on name then it will call GREET-API and will get the response.
----------------------------------------------------------------------------------
FeignClient & Interservice Communication
------------------------------------------------------------------------
-> In one project we will develop multiple services
-> If one service wants to communicate with another service in same project then we will call it as Interservice Communication.
-> To achieve Interservice Communication we will use FeignClient.
-> FeignClient will get service url from service registry based on service name.
---------------------------------------------------------------------------------
API Gateway
---------------------------------------------------------------------------------
-> API Gateways acts as single entry point for all the backednd apis available in the application.
-> API Gateway is used to manage all the apis available in the application.
-> We can use Zuul Proxy as API Gateway
-> Zuul Proxy provided by Spring Cloud Netflix Library

Mini Project Requirement
---------------------------------------------------------------------------------------------
-> What is Service Registry ?
-> What is Eureka Client ?
-> How to register our API with Eureka Server ?
-> What is Interservice Communication ?
-> What is FeignClient?
-> What is API Gateway ?
-> How to configure Routing in API Gateway ?
----------------------------------------------------------------------------------------------
-> We can pass Embedded Server PORT number as an VM argument
-> Right Click On Project -> Run As -> Run Configurations -> Arguments -> VM Arguments
		-Dserver.port=1111
-------------------------------------------------------------------------------------------
->  We can get server port number using Environment Object
-------------------------------------------------------------------------------------------
package in.ashokit.rest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class WelcomeRestController {

	@Autowired
	private Environment env;

	@GetMapping("/welcome")
	public String welcomeMsg() {
		String port = env.getProperty("server.port");
		String msg = "Welcome to Ashok IT..!!" + " Server Running On :: " + port;
		return msg;
	}
}
----------------------------------------------------------------------------------------------
Mini Project Introduction
----------------------------------------------------------------------------------------------
STOCK-PRICE-API : This api will maintain company stock prices in db table. This api will take company name as input and it will provide company stock price as output.
STOCK-CALC-API : This api is used to calculate total stocks cost based on quantity. This api will take company_name & quantity as input and it will return total_cost as output.
Note: STOCK-CALC-API will get stock_price from STOCK-PRICE-API based on company_name.
Mini Project Requirement
---------------------------------------------------------------------------------------------
-> We are developing Stock Market Application using Microservices Architecture
-> We have below 2 backend apis
		i) STOCK-PRICE-API
		ii) STOCK-CALC-API

-> STOCK-PRICE-API will maintain companies stock-price-details and it will take company-name as input and it will return company-stock-price as output.
-> STOCK-CALC-API is used to calculate total stocks cost based on quantity. This API will communicate with STOCK-PRICE-API using FeginClient to get company stock-price.
-> We will have service registry to register all the backend apis
-> We will have API-GATEWAY to manage all the backend apis and routings.
-> We will have front-end application with User Interface.
---------------------------------------------------------------------------------------------
Steps to develop STOCK-SERVICE-REGISTRY API
---------------------------------------------------------------------------------------------
1) Develop Service-Registry Application with Eureka Server
2) Configure below dependencies
	1)netflix-eureka-server
		2)devtools
3) Write @EnableEurekaServer dependency at Spring Boot start class
4) Configure Port Number as 8761 and disable self-registration
server:
  port: 8761
eureka:
  client:
    register-with-eureka: false

5) Run the application and verify Eureka Server Dashboard

		http://localhost:8761/
----------------------------------------------------------------------------------------------
Steps to develo STOCK-PRICE-API
----------------------------------------------------------------------------------------------
1) create spring boot starter project with below dependencies

		i)spring-boot-starter-web
		ii)spring-cloud-sterter-netflix-eureka-client
		iii)spring-boot-starter-data-jpa
		iv) H2
		v) spring-boot-starter-actuator
		vi) swagger & swagger-ui
		vii) spring-boot-devtools		

2) Configure below properties in application.yml file

		i) server-port
		ii) application-name
		iii) datasource-props
		iv) actuator-props

server:
  port: 1111
spring:
  application:
    name: STOCK-PRICE-API
  datasource:
    url: jdbc:mem:h2:testDB
    username: SA
    password: null
    driver-class-name: org.h2.Driver
management:
  endpoints:
    web:
      exposure:
        include: '*'

3) Create Entity class & Repository Interface to perform DB operation

4) Keep below insert queries in src/main/resources/data.sql file to insert into DB when application got started.
insert into STOCK_PRICE_DTLS(STOCK_PRICE_ID,COMPANY_NAME,COMPANY_STOCK_PRICE) values (101,'SBI',430.00);
insert into STOCK_PRICE_DTLS(STOCK_PRICE_ID,COMPANY_NAME,COMPANY_STOCK_PRICE) values (102,'BHEL',43.00);
insert into STOCK_PRICE_DTLS(STOCK_PRICE_ID,COMPANY_NAME,COMPANY_STOCK_PRICE) values (103,'HDFC',1400.00);
insert into STOCK_PRICE_DTLS(STOCK_PRICE_ID,COMPANY_NAME,COMPANY_STOCK_PRICE) values (104,'HCL',950.00);
insert into STOCK_PRICE_DTLS(STOCK_PRICE_ID,COMPANY_NAME,COMPANY_STOCK_PRICE) values (105,'TCS',2950.00);
Note: H2 is a temporary database. When application start then DB will start when application stopped DB will be stopped.

5) Create Response Binding Class for our api
6) Create Service Layer method which will interact with Repository to fetch stock-price based on company name
7) Create RestController to handle request (input=companyName & output=StockPriceResponse)
8) Create Swagger Configuration class to provide documentation for API
9) Configure @EnableDiscoveryClient annotation at boot start class to represent this as EurekaClient application.
10) Run the application and verify

STOCK-CALC-API & API-GATEWAY
---------------------------------------------------------------------------------
1) Create Spring Starter application with below dependencies

		1)spring-boot-starter-web
		2)spring-cloud-starter-netflix-eureka-client
		3)spring-boot-starter-actuator
		4)spring-cloud-starter-open-feign
		5)spring-boot-devtools
		6)swagger & swagger-UI
		7)project-lombok

2) Create Request & Response Binding classes
3) Create FeignClient to access STOCK-PRICE-API
4) Create Service Layer class to invoke STOCK-PRICE-API using FeignClient and execute business logic
5) Create Rest Controller to handle requet
6) Create Swagger Config class to provide documentation
7) Write below 2 annotations in spring boot start class
		@EnableDiscoveryClient
		@EnableFeignClients

8) Configure below properties in application.yml file
		i)server-port
		ii)application-name
		iii)actuator props

8) Run the application and test it.		

Backend Development Completed For Mini Project
----------------------------------------------------------------------------------
-> As part of Mini project we developed below APIs
		1) STOCK-PRICE-API
		2) STOCK-CALC-API
		3) SERVICE-REGISTRY-API
		4) GATEWAY-API
---------------------------------------------------------------------------------
Today's session : Load Balancing
---------------------------------------------------------------------------------
-> Load Balancing is the process of distributing load from one server to multiple servers.
-> If we deploy our application in one server then it is responsible to handle all incoming requests.
-> If all requests are going to single server then burden will increase on the server.
-> If burden increased on server then we will see below issues
		1) Response Delay
		2) Server Crash etc..
-> To avoid these problems we will deploy our application using Load Balancer.
-> Load Balancing we can implement in 2 ways
		1) Server Side Load Balancing
		2) Client Side Load Balancing

Load Balancing & Load Balancing Algorithms
---------------------------------------------------------------------------------
-> Load Balancing is the process which is used to distribute the load of server
-> If we deploy our application in one server then burden will increase on that server. If burden is increased then response may be delayed and server can crash.
-> To reduce burden on server, we will deploy our application into multiple servers using load balancer.
-> Load balancing we can implement in 2 ways
		1) Server Side Load Balancing
		2) Client Side Load Balancing
----------------------------------------------------------------------------------
-> To implement Server Side balancing Load Balancer algorithm will be configured to decide which request should be processed by which server.
			i) Round Robbin
			ii) Sticky Session
			iii) Ip Hashing
Q) What is scale up?
Q) What is scale down?
-> Adding more servers to LBR based on demand is called as Scale up.
-> Removing servers from LBR is called as Scaled down.
-> Adding servers and removing servers manually is time taking process.
-> Now a days we are using Auto-Scaling.
Q) What is Auto Scaling?
-> It is the process of adding and removing servers from LBR based on demand.
Ex: Amazon BigDay sale, Flipkart BigDay Sale etc..
-> Companies can't guess traffic on Big Day sale thats why they will prefer AutoScaling.
---------------------------------------------------------------------------------
1) Spring Boot Admin Server & Client
2) Distributed Logging (Slueth & Zipkin)
3) Circuit Breaker
4) Connecting with Multiple Databases
5) Securing Rest APIs
6) Apache Kafka
7) Redis Cache
8) Angular Integration
9) Docker
10) Profiles in Spring Boot (Video)
11) Exception Handling in Rest API (Video)
---------------------------------------------------------------------------------
Spring Boot Admin Server & Admin Client
---------------------------------------------------------------------------------
-> Spring Boot provided actuators to get production ready features
-> Spring boot actuators having below endpoints

		- info
		- health
		- beans
		- mappings
		- env
		- shutdown
		- threaddump
		- heapdump
		- httpTrace etc.
-> To work with actuators we have to add below starter in pom.xml file
		1)spring-boot-starter-actuator
-> To expose actuator endpoints we will write below configuration
	management.endpoints.web.exposure.include= '*'
-> To see exposed endpoints of our application we can use below url
		http://localhost:portnumber/actuator/
-> Admin Server is providing user interface to monitor all the registered services at one place using actutor endpoints.
---------------------------------------------------------------------------------
Steps to develop admin server project
--------------------------------------------------------------------------------
1) Create Spring Boot application with Admin-server dependency
	<dependency>
		<groupId>de.codecentric</groupId>
		<artifactId>spring-boot-admin-starter-server</artifactId>
	</dependency>
2) Write below annotation at Spring Boot start class
@SpringBootApplication
@EnableAdminServer
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}

3) Configure port number
4) Run the application and access admin-server-dashboard
------------------------------------------------------------------------------------------
Steps to develop Admin Client Application
-------------------------------------------------------------------------------------------
1) Create Spring Boot Application with below dependencies
		i)starter-web
		ii)actuator
		iii)admin-client
		iv) devtools
<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>de.codecentric</groupId>
			<artifactId>spring-boot-admin-starter-client</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
			<exclusions>
				<exclusion>
					<groupId>org.junit.vintage</groupId>
					<artifactId>junit-vintage-engine</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
	</dependencies>

2) Configure below properties in application.yml file
	
		i)server-port
		ii) application-name
		iii) actuator-props
		iv) admin-server-app-url

server:
  port: 2222
spring:
  application:
    name: CLIENT-TWO
  boot:
    admin:
      client:
        url: http://localhost:9090/
management:
  endpoints:
    web:
      exposure:
        include: '*'

3) Create Rest Controller with Required Methods

4) Run the application and verify Admin-Server-Dashboard

--------------------------------------------------------------------------------------------
Distributed Logging (Using Sleuth & Zipkin)
-----------------------------------------------------------------------------------------
-> Download Zipkin Server (it is a jar file)
-> Run Zipkin server using below command
	java -jar  zipkin-server.jar
Note: Zipkin server will run on the port number 9411 (http://localhost:9411)
-> Create Spring Boot application with below dependencies
<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-sleuth</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-zipkin</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
			<exclusions>
				<exclusion>
					<groupId>org.junit.vintage</groupId>
					<artifactId>junit-vintage-engine</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
	</dependencies>
-> Configure server-port and application-name in yml file
-> Create Rest Controller with Required methods
-> Run the application and test it.
Note: Application execution log details can be monitored in zipkin server dashboard.
Note: Now a days in the industry we are using Splunk for this.
---------------------------------------------------------------------------------------------
 Apache Kafka
--------------------------------------------------------------------------------
-> Distributed systems are collection of computers that work together to form single computer for end users.
-> Distributed systems can handle billions of requests and upgrades without downtime.
-> Apache Kafka has become one of the most widely used Distributed Systems on the market today.
-------------------------------------------------------------------------------
-> Apache Kafka is an open-source distributed event streaming platform used by thousands of companies for high-performance and data pipelines, streaming analysis, data integration, and mission-critical applications.
-> Kafka is used by most fortune 100 companies like Linkedin, Netflix and Microsoft etc.
-> Apache Kafka is an open-source software which is written in Scala and Java programming languages.
-> Kafka started in 2011 as a messaging system for Linkedin but has since grown to became a popular distributed event streaming platform.
-> Apache Kafka is capable of handling trillions of records per day.

Apache Kafka Use cases
----------------------
1) Processing financial transactions in realtime
2) Tracking and Monitoring Trasportation Vehicles in real-time
3) Capturing and Analyzing sensor data
4) Collecting and reacting to customer interaction
5) Monitoring hospital patients
6) To develop Event-Driven Microservices etc..

What is Apache Kafka and why we need it?
---------------------------------------------------------------------------------
-> Apache kafka is a distributed streaming platform
-> Apache Kafka came into market in 2011
-> Now a days Apache Kafka became most trending Message Broker
-> Apache Kafka implemented using Scala and Java programming languages
-> To process realtime stream data we will use apache kafka
-> Applications can exchange messages using Kafka as a message broker
---------------------------------------------------------------------------------
-> Apache Kafka works based on Pub-Sub model
		1) Publisher Application
		2) Subscriber Application
-> The application which will publish the message to Kafka is called as Publisher Application
-> The application which will consume the message from kafka is called as Subscriber application.
---------------------------------------------------------------------------------
Spring Boot + Apache Kafka Application
=================================================================================
Step-1 : Download Zookeeper from below URL
   URL : http://mirrors.estointernet.in/apache/zookeeper/stable/
Step-2 : Download Apache Kafka from below URL
   URL : http://mirrors.estointernet.in/apache/kafka/
Step-3 : Set Path to ZOOKEEPER in Environment variables upto bin folder
Step-4 : Start Zookeeper server using below command from Kafka folder
    Command : zookeeper-server-start.bat zookeeper.properties
Note: Above command will available in kafka/bin/windows folder
Note: zookeeper.properties file will be available in config folder. You can copy zookeeper.properties and server.properties files from kafka/config folder to kafka/bin/windows folder.

Step-5: Start Kafka Server using below command from Kakfa folder
    Command : kafka-server-start.bat server.properties
Note: server.properties file will be available in config folder (Copied to windows folder)
Step-6 : Create Kakfa Topic using below command
Command : kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic 09-sbms-topic
Step-7 : View created Topics using below command
      Command : kafka-topics.bat --list --zookeeper localhost:2181
Step-8 : Create Spring Boot Project in IDE
===========================================
Step-9: Add below kafka related dependencies in pom.xml
		<dependency>
			<groupId>org.apache.kafka</groupId>
			<artifactId>kafka-streams</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.kafka</groupId>
			<artifactId>spring-kafka</artifactId>
		</dependency>
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
		</dependency>
		

Step-9: Create RestController, Service, KafaProducerConfig and KafaConsumerConfig classes to publish and subsribe messages
Step-10: Test application using PostMan.

Sample Data
------------
[

{"customerId":101,
"customerName":"Ashok",
"customerEmail":"ashok@gmail.com"
},

{
"customerId":102,
"customerName":"Raj",
"customerEmail":"raj@gmail.com"
},
{
"customerId":102,
"customerName":"John",
"customerEmail":"john@gmail.com"
}

]
---------------------------------------------------------------------------------
Cache Introduction
-------------------------------------------------------------------------
-> Cache is a memory which is used to store the data in key-value format
-> If our application having a requirement to use satic data then it is highly recommended to use Cache in that application.
-> Using cache data we can reduce no.of db calls and we can improve performance of the application.
-> If we want to use cache in one application then we will go for Local cache. Local cache means we will implement with in our application.
------------------------------------------------------------------------
@Data
public class Cache{
    private Map<String, Object> data = new HashMap<>();

    public static boolean put(String key, Object val){
	return	data.put(key, Object);
    }

    public static Object get(String key){
	return data.get(key);
     }
}
-------------------------------------------------------------------------
@Component
public class MyCacheRunner implements CommandLineRunner{
      public void run(){
		//load the data from db
		//store the data into cache
      }
}
-----------------------------------------------------------------------
-> If we want to use cache data in multiple applications then we will go for Distributed Cache.
-> Redis is one of the famous distributed cache.
------------------------------------------------------------------------

 What is Cache & why we need to go for cache
------------------------------------------------------------------------
-> Cache is a temporary storage which is used to store & access the data frequently.
-> In our application we will deal with two types of tables
		1) Transactional tables
		2) Non-transactional tables
-> If application is performing insert/update/delete operations in the table then it is called as transactional table.
-> If application is performing only select(read) operation on the table then that table is called as non-transactional table.
-> The data which we have in non-transactional table is called as static data.
-> If we are using static data in our application then we can implement cache to improve performance of the application.

How to implement cache
----------------------
-> Once application got started take data from db and store that into cache in the form of key-value pair.
-> When application needs that data take it from cache memory instead of making db call.
-> By using cache memory we can reduce no.of db calls hence application performance will be improved.

Q) What is Local cache & What is distributed cache ?
-----------------------------------------------------
-> If we implement cache with in one application then it called as local cache.
-> If we want to use cache data in multiple applications then we should go for distributed cache (Ex: Redis cache)

Q) What is Redis?
------------------
-> Redis is an open source cache which is used to store the data in the form key-value pair.
-> Multiple applications can connect to Redis cache to access the data.

------------------------------------------------------------------------
Environment Setup
------------------------------------------------------------------------
1) download redis-server software
2) Extract downloaded zip file
3) Double click on redis-server.exe file (redis server will start)
4) Double click on redis-cli.exe file
5) Type ping in client cmd it will respond with PONG.

Note : With this redis server setup is ready.
Note: In realtime, redis-server will be installed in remote machine and they will share redis-server details (url, uname, pwd and port)
-----------------------------------------------------------------------
Spring Boot Application with Redis Integration
------------------------------------------------------------------------
1) Create Spring Boot application with below dependencies
		1) spring-boot-starter-web
		2) spring-boot-starter-redis
		3) project lombok
		4) devtools
		5) swagger & swagger-ui

2) Configure JedisConnectionFactory bean with Redis Server details & inject JedisConnectionFactory bean into RedisTemplate bean
3) Create Entity class
4) Create Repository Class with required methods. Inject RedisTemplate into Repository bean and get HashOperations object to perform redis operations.
5) Create Rest Controller with required methods
6) Create Swagger Config class
7) Configure Server port
8) Run the application and test it.

----------------------------------------------------------------------------------
<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>io.springfox</groupId>
			<artifactId>springfox-swagger2</artifactId>
			<version>2.6.1</version>
		</dependency>

		<dependency>
			<groupId>io.springfox</groupId>
			<artifactId>springfox-swagger-ui</artifactId>
			<version>2.6.1</version>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>
----------------------------------------------------------------------------------
package com.tekleads;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;

import com.tekleads.model.User;

@SpringBootApplication
public class SpringRedisExampleApplication {

	@Bean
	JedisConnectionFactory jedisConnectionFactory() {
		JedisConnectionFactory jcf = new JedisConnectionFactory();
		//jcf.setHostName(hostName);
		//jcf.setPassword(password);
		//jcf.setPort(port);
		return jcf;
	}

	@Bean
	RedisTemplate<String, User> redisTemplate() {
		RedisTemplate<String, User> redisTemplate = new RedisTemplate<>();
		redisTemplate.setConnectionFactory(jedisConnectionFactory());
		return redisTemplate;
	}

	public static void main(String[] args) {
		SpringApplication.run(SpringRedisExampleApplication.class, args);
	}
}
----------------------------------------------------------------------------------
@Data
public class User implements Serializable {

	private String id;
	private String name;
	private Long salary;

}
----------------------------------------------------------------------------------
public interface UserRepository {

	void save(User user);

	Map<String, User> findAll();

	User findById(String id);

	void update(User user);

	void delete(String id);
}
---------------------------------------------------------------------------------
package com.tekleads.repository;

import java.util.Map;

import org.springframework.data.redis.core.HashOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Repository;

import com.tekleads.model.User;

@Repository
public class UserRepositoryImpl implements UserRepository {

	private HashOperations<String, String, User> hashOperations;

	public UserRepositoryImpl(RedisTemplate<String, User> redisTemplate) {
		hashOperations = redisTemplate.opsForHash();
	}

	@Override
	public void save(User user) {
		hashOperations.put("USER", user.getId(), user);
	}

	@Override
	public Map<String, User> findAll() {
		return hashOperations.entries("USER");
	}

	@Override
	public User findById(String id) {
		User user = (User) hashOperations.get("USER", id);
		return user;
	}

	@Override
	public void update(User user) {
		save(user);
	}

	@Override
	public void delete(String id) {
		hashOperations.delete("USER", id);
	}
}
----------------------------------------------------------------------------------
package com.tekleads.rest;

import java.util.Map;

import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.tekleads.model.User;
import com.tekleads.repository.UserRepository;

@RestController
@RequestMapping("/rest/user")
public class UserResource {

	private UserRepository userRepository;

	public UserResource(UserRepository userRepository) {
		this.userRepository = userRepository;
	}

	@PostMapping(value = "/add", consumes = "application/json")
	public User add(@RequestBody User user) {
		userRepository.save(user);
		return userRepository.findById(user.getId());
	}

	@PutMapping("/update/{id}/{name}")
	public User update(@PathVariable("id") final String id, @PathVariable("name") final String name) {
		userRepository.update(new User(id, name, 1000L));
		return userRepository.findById(id);
	}

	@DeleteMapping("/delete/{id}")
	public Map<String, User> delete(@PathVariable("id") final String id) {
		userRepository.delete(id);
		return all();
	}

	@GetMapping("/all")
	public Map<String, User> all() {
		Map<String, User> findAll = userRepository.findAll();
		return findAll;
	}
}
----------------------------------------------------------------------------------
 Spring Boot with Redis Integration
------------------------------------------------------------------------
-> JedisConnectionFactory (To connect with Redis Server)
-> RedisTemplate
-> HashOperations (Provided methods to perform operations)
		- put( )
		- get( )
		- entries( )
		- delete( )
-------------------------------------------------------------------------
Circuit Breaker & Multiple Data sources in Boot
Securing Rest api (Basic Auth, oAuth2.0 & JWT)
Angular Integration
Spring Boot with MongoDB
Data JPA Joins Example
Config Server
Docker
-------------------------------------------------------------------------
try{
    //logic to get data from redis
}catch(Exception e){
    //logic to get data from db
}
------------------------------------------------------------------------

@CircuitBreaker(faultTolerenceMethod="getFromDB")
public Object getFromRedis(){
	//logic
}

public Object getFromDB(){
	//logic 
}
-------------------------------------------------------------------------
if 3 requests failed to get data from redis then break circuit for 30 mins

Circuit Breaker with Multiple database connection in boot
------------------------------------------------------------------------
-> To connect with multiple databases, we should have configure multiple datasoures
-> Circuit Breaker is used to execute fallback logic when main logic got failed to execute.
-> Using circuit breaker we can develop fault tolerance and high availability systems.
-------------------------------------------------------------------------
Spring Security
-------------------------------------------------------------------------
-> For every application we should provide some security to protect that application from hackers.
-> In realtime applications, every client is asking to provide security
-> As per the most recent verizon data breach investigation report-2020, 43% of data breaches were attacks on web applications.
-> To protect our application from hacker attacks & data breaches we can use Spring Security concept.
---------------------------------------------------------------------------------
-> Spring Security works on a concept called JAAS (Java Authentication & Authorization Services).
-> In brief, Spring security mainly works on javax.servlet.Filter concept.
-> Filters are used to apply some pre-processing logic based on that we can decide weather to process that request or not.
-> In Spring Security we have predefined filter class to apply pre-processing logic for the request
			DelegatingFilterProxy
-> DelegaringFilterProxy will check for below 2 things
		1) Authentication
		2) Authorization
-> Authentication is the process of checking weather this user can access our application or not.
-> Authorization is the process of checking weather this user having access for this functionality/page or not.
---------------------------------------------------------------------------------
-> We can implement spring boot security authentication in below 3 ways
	i) In-Memory Credentials Security
	ii) Using Data base (JDBC)
	iii) Using UserDetailsService


-> We can implement spring boot security authorization in below 4 ways
i) permitAll  : no authorization required, all pages can be accessed
ii) authenticated : if authentication pass, page can access 
iii) hasAuthority : If user authenticated and authorized then only he can
iv) hasAnyAutority : if user having any role which are configure then it can access

What is Authentication & Authorization & Spring Security
-------------------------------------------------------------------------
-> Spring team provided security module to protect our applications from hackers and from data breaches
-> Spring Security is providing below 2 functionalities
		1) Authentication
		2) Authorization
-> Authentication talks about weather the user can access our application nor not.
-> Authorization talks about weather the user having access for that functionality or not.
-> Spring Security works based on a filter. Spring Security using DelegatingFilterProxy.
-> If application having Spring Security then request will go to Filter first then it will go to dispatcher servlet.
-Spring Security with In-Memory Credentials
---------------------------------------------------------------------------------
-> In-Memory credentials means with-in application we will configure credentials of the users.
1) Create Spring Boot application with below dependencies
		i) spring-boot-starter-web
		ii) spring-boot-starter-security
		iii) spring-boot-starter-thymeleaf
	iv) devtools
2) Create Controller class with Required methods
3) Create View Files using Thymeleaf
4) Create Security Config class
5) Run the application and test it.

----------------------------------------------------------------------------------
package in.ashokit.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class HomeController {

	@GetMapping("/home")
	public String getHomePage() {
		return "homePage";
	}

	@GetMapping("/welcome")
	public String getWelcomePage() {
		return "welcomePage";
	}

	@GetMapping("/admin")
	public String getAdminPage() {
		return "adminPage";
	}

	@GetMapping("/emp")
	public String getEmpPage() {
		return "empPage";
	}

	@GetMapping("/mgr")
	public String getMgrPage() {
		return "mgrPage";
	}

	@GetMapping("/common")
	public String getCommonPage() {
		return "commonPage";
	}

	@GetMapping("/accessDenied")
	public String getAccessDeniedPage() {
		return "accessDeniedPage";
	}
}
----------------------------------------------------------------------------------
package in.ashokit.security;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

	/**
	 * In this method we will configure Authentication credentials
	 */
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {

		// {noop} --> No Operation for password encoder

		auth.inMemoryAuthentication().withUser("devs").password("{noop}devs").authorities("ADMIN");
		auth.inMemoryAuthentication().withUser("ns").password("{noop}devs").authorities("EMPLOYEE");
		auth.inMemoryAuthentication().withUser("vs").password("{noop}devs").authorities("MANAGER");

	}

	/**
	 * In this method we will configure Authorization roles
	 */
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		
			http.authorizeRequests()
				.antMatchers("/home").permitAll()
				.antMatchers("/welcome").authenticated()
				.antMatchers("/admin").hasAuthority("ADMIN")
				.antMatchers("/emp").hasAuthority("EMPLOYEE")
				.antMatchers("/mgr").hasAuthority("MANAGER")
				.antMatchers("/common").hasAnyAuthority("EMPLOYEE", "MANAGER")
				
				.anyRequest().authenticated()
				
				.and()
				.formLogin()
				.defaultSuccessUrl("/welcome",true)
				
				.and()
				.logout()
				.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))
				
				.and()
				.exceptionHandling()
				.accessDeniedPage("/accessDenied");
		
	}

}
----------------------------------------------------------------------------------